import uuid
import logging
from fastapi import APIRouter, HTTPException, BackgroundTasks, Request
from api.models import (
    TripPlanningRequest,
    FollowUpQuestion,
    ItineraryResponse,
    RefinementRequest,
    BookingSummary
)
from api.ai_trip_planner import ai_planner
from datetime import datetime
import re
from datetime import timedelta
from api.models import TripType, BudgetRange

router = APIRouter(prefix="/trip-planner", tags=["AI Trip Planner"])
logger = logging.getLogger(__name__)

@router.post("/start")
async def start_trip_planning(request: TripPlanningRequest):
    """Start a new trip planning session with AI agents"""
    try:
        # Generate a unique session ID
        session_id = str(uuid.uuid4())
        
        # Create a new conversation session
        session = ai_planner.create_session(session_id)
        session.trip_request = request
        session.current_step = "gathering_info"
        
        # Determine what follow-up questions we need
        follow_up_questions = ai_planner.determine_follow_up_questions(request, session)
        
        # Create acknowledgment message based on what was provided
        acknowledgment_parts = []
        if request.origin and request.destination:
            acknowledgment_parts.append(f"from {request.origin} to {request.destination}")
        if request.duration_days:
            acknowledgment_parts.append(f"for {request.duration_days} days")
        if request.travelers and request.travelers > 1:
            acknowledgment_parts.append(f"for {request.travelers} travelers")
        
        acknowledgment = f"Great! I understand you want to plan a trip {' '.join(acknowledgment_parts)}."
        
        # If we have all the information we need, generate itinerary with agents
        if not follow_up_questions:
            session.current_step = "generating_itinerary"
            itinerary = await ai_planner.generate_itinerary(request)
            
            if "error" in itinerary:
                raise HTTPException(status_code=500, detail=itinerary["error"])
            
            session.itinerary = itinerary
            session.current_step = "itinerary_ready"
            
            return {
                "session_id": session_id,
                "status": "itinerary_ready",
                "itinerary": itinerary,
                "message": f"{acknowledgment} Your itinerary has been generated by our AI agent team!",
                "can_refine": True,
                "remaining_refinements": session.max_refinements,
                "agents_used": itinerary.get("agent_system", {}).get("agents_used", [])
            }
        
        # Return follow-up questions with better acknowledgment
        missing_count = len(follow_up_questions)
        if missing_count == 1:
            message = f"{acknowledgment} I just need one more detail to create your perfect itinerary."
        else:
            message = f"{acknowledgment} I need {missing_count} more details to create your perfect itinerary with our AI agents."
        
        return {
            "session_id": session_id,
            "status": "gathering_info",
            "follow_up_questions": [q.dict() for q in follow_up_questions],
            "message": message
        }
        
    except Exception as e:
        logger.error(f"Error starting trip planning: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/{session_id}/answer")
async def answer_follow_up(session_id: str, answers: dict):
    """Answer follow-up questions and continue planning with AI agents"""
    try:
        session = ai_planner.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Update trip request with answers and track provided fields
        for field_name, value in answers.items():
            if hasattr(session.trip_request, field_name):
                # Handle special field types
                if field_name == "budget_range" and isinstance(value, str):
                    # Convert string to BudgetRange enum
                    from api.models import BudgetRange
                    try:
                        value = BudgetRange(value)
                    except ValueError:
                        logger.error(f"Invalid budget_range value: {value}")
                        continue
                elif field_name == "trip_type" and isinstance(value, str):
                    # Convert string to TripType enum
                    from api.models import TripType
                    try:
                        value = TripType(value)
                    except ValueError:
                        logger.error(f"Invalid trip_type value: {value}")
                        continue
                
                setattr(session.trip_request, field_name, value)
                # Track that this field has been provided
                if field_name not in session.provided_fields:
                    session.provided_fields.append(field_name)
        
        # Check if we have enough information now
        follow_up_questions = ai_planner.determine_follow_up_questions(session.trip_request, session)
        
        if not follow_up_questions:
            # Generate itinerary with AI agents
            session.current_step = "generating_itinerary"
            itinerary = await ai_planner.generate_itinerary(session.trip_request)
            
            if "error" in itinerary:
                raise HTTPException(status_code=500, detail=itinerary["error"])
            
            session.itinerary = itinerary
            session.current_step = "itinerary_ready"
            
            return {
                "session_id": session_id,
                "status": "itinerary_ready",
                "itinerary": itinerary,
                "message": "Perfect! Your itinerary has been generated by our AI agent team.",
                "can_refine": True,
                "remaining_refinements": session.max_refinements,
                "agents_used": itinerary.get("agent_system", {}).get("agents_used", [])
            }
        
        # Still need more information
        missing_count = len(follow_up_questions)
        if missing_count == 1:
            message = "Thanks! I just need one more detail to complete your itinerary."
        else:
            message = f"Thanks! I need {missing_count} more details to complete your itinerary."
        
        return {
            "session_id": session_id,
            "status": "gathering_info",
            "follow_up_questions": [q.dict() for q in follow_up_questions],
            "message": message
        }
        
    except Exception as e:
        logger.error(f"Error processing follow-up answers: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/{session_id}/refine")
async def refine_itinerary(session_id: str, refinement: RefinementRequest):
    """Refine the itinerary using specialized AI agents"""
    try:
        session = ai_planner.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        if not session.itinerary:
            raise HTTPException(status_code=400, detail="No itinerary to refine")
        
        if session.refinement_count >= session.max_refinements:
            raise HTTPException(status_code=400, detail="Maximum refinements reached")
        
        # Use the new agent-based refinement system
        result = await ai_planner.refine_itinerary_with_agents(session_id, refinement)
        
        if "error" in result:
            raise HTTPException(status_code=400, detail=result["error"])
        
        return {
            "session_id": session_id,
            "status": "refinement_processed",
            "message": result["message"],
            "agents_involved": result.get("agents_involved", []),
            "refined_itinerary": result.get("refined_itinerary", session.itinerary),
            "can_refine": result['remaining_refinements'] > 0,
            "remaining_refinements": result['remaining_refinements']
        }
        
    except Exception as e:
        logger.error(f"Error refining itinerary: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{session_id}/agents")
async def get_agent_insights(session_id: str):
    """Get insights from the AI agents that worked on this itinerary"""
    try:
        session = ai_planner.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        if not session.itinerary:
            raise HTTPException(status_code=400, detail="No itinerary available")
        
        agent_insights = session.itinerary.get("agent_insights", {})
        agent_system = session.itinerary.get("agent_system", {})
        
        return {
            "session_id": session_id,
            "agent_system": agent_system,
            "agent_insights": agent_insights,
            "refinement_history": [
                entry for entry in session.conversation_history 
                if entry.get("type") == "refinement"
            ]
        }
        
    except Exception as e:
        logger.error(f"Error getting agent insights: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{session_id}/status")
async def get_session_status(session_id: str):
    """Get the current status of a planning session"""
    try:
        summary = ai_planner.get_conversation_summary(session_id)
        
        if "error" in summary:
            raise HTTPException(status_code=404, detail=summary["error"])
        
        return summary
        
    except Exception as e:
        logger.error(f"Error getting session status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/{session_id}/finalize")
async def finalize_itinerary(session_id: str):
    """Finalize the itinerary and prepare for booking"""
    try:
        session = ai_planner.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        if not session.itinerary:
            raise HTTPException(status_code=400, detail="No itinerary to finalize")
        
        # Here you would integrate with Booking.com API to get real booking data
        # For now, return a placeholder booking summary
        
        booking_summary = {
            "session_id": session_id,
            "flights": [
                {
                    "from": session.trip_request.origin,
                    "to": session.itinerary.get("overview", {}).get("route_sequence", ["Unknown"])[0],
                    "airline": "Sample Airline",
                    "price": "$800-1200",
                    "booking_link": "https://booking.com/flights"
                }
            ],
            "hotels": [
                {
                    "name": "Sample Hotel",
                    "location": "City Center",
                    "price_per_night": "$150-200",
                    "booking_link": "https://booking.com/hotels"
                }
            ],
            "total_cost": "$2000-3000",
            "booking_links": {
                "flights": "https://booking.com/flights",
                "hotels": "https://booking.com/hotels"
            },
            "itinerary_summary": "Your AI-planned trip is ready for booking!",
            "agent_recommendations": session.itinerary.get("agent_system", {}).get("agents_used", [])
        }
        
        session.current_step = "ready_for_booking"
        
        return {
            "session_id": session_id,
            "status": "ready_for_booking",
            "booking_summary": booking_summary,
            "message": "Your AI agent-planned itinerary is finalized and ready for booking!"
        }
        
    except Exception as e:
        logger.error(f"Error finalizing itinerary: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.delete("/{session_id}")
async def delete_session(session_id: str):
    """Delete a planning session"""
    try:
        if session_id in ai_planner.conversation_sessions:
            del ai_planner.conversation_sessions[session_id]
            return {"message": "Session deleted successfully"}
        else:
            raise HTTPException(status_code=404, detail="Session not found")
    except Exception as e:
        logger.error(f"Error deleting session: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/{session_id}/search-flights")
async def search_flights_for_trip(session_id: str, flight_request: dict):
    """Search for flights for a specific trip planning session"""
    try:
        session = ai_planner.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Extract flight search parameters
        origin = flight_request.get('origin', session.trip_request.origin if session.trip_request else '')
        destination = flight_request.get('destination', session.trip_request.destination if session.trip_request else '')
        start_date = flight_request.get('start_date', session.trip_request.start_date if session.trip_request else '')
        return_date = flight_request.get('return_date', '')
        travelers = flight_request.get('travelers', session.trip_request.travelers if session.trip_request else 1)
        
        if not origin or not destination:
            raise HTTPException(status_code=400, detail="Origin and destination are required")
        
        # Create flight search task
        from api.ai_agents import AgentTask, AgentType
        flight_search_task = AgentTask(
            agent_type=AgentType.FLIGHT_SEARCH_AGENT,
            task_description="Search for real flight options using Booking.com API",
            required_data={
                "origin": origin,
                "destination": destination,
                "start_date": start_date,
                "return_date": return_date,
                "travelers": travelers
            }
        )
        
        # Execute flight search
        flight_search_result = await ai_planner.ai_agent.execute_agent_task(flight_search_task)
        
        if "error" in flight_search_result.result:
            raise HTTPException(status_code=500, detail=flight_search_result.result["error"])
        
        # Add to session history
        session.conversation_history.append({
            "type": "flight_search",
            "search_params": flight_request,
            "results": flight_search_result.result,
            "timestamp": datetime.now().isoformat()
        })
        
        return {
            "session_id": session_id,
            "flight_search_results": flight_search_result.result.get("flight_search_results", {}),
            "agent_confidence": flight_search_result.confidence,
            "agent_reasoning": flight_search_result.reasoning
        }
        
    except Exception as e:
        logger.error(f"Error searching flights for trip: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/start-natural")
async def start_trip_planning_natural(request: dict):
    """Start trip planning with natural language input"""
    try:
        user_query = request.get('query', '')
        if not user_query:
            raise HTTPException(status_code=400, detail="No query provided")
        
        # Parse natural language input
        from api.enhanced_parser import EnhancedQueryParser
        parser = EnhancedQueryParser()
        
        # Extract basic information from the query
        query_lower = user_query.lower()
        
        # Simple pattern matching for common trip planning phrases
        origin = None
        destination = None
        duration_days = None
        start_date = None
        
        # Extract "from X to Y" pattern - improved to handle commas and state codes
        from_match = re.search(r'from\s+([a-zA-Z\s,]+?)\s+to\s+([a-zA-Z\s,]+?)(?:\s+for|\s+in|\s+on|\s+starting|$)', query_lower)
        if from_match:
            origin = from_match.group(1).strip()
            destination = from_match.group(2).strip()
            
            # Clean up the extracted values - remove state codes and extra commas
            origin = re.sub(r',\s*[A-Z]{2}$', '', origin).strip()  # Remove state codes like ", TX"
            destination = re.sub(r',\s*[A-Z]{2}$', '', destination).strip()  # Remove state codes like ", CA"
            
            # Remove trailing commas
            origin = origin.rstrip(',').strip()
            destination = destination.rstrip(',').strip()
        
        # Extract duration (e.g., "for 3 days", "3 days", "3-day")
        duration_match = re.search(r'for\s+(\d+)\s*days?', query_lower)
        if not duration_match:
            duration_match = re.search(r'(\d+)\s*days?', query_lower)
        if duration_match:
            duration_days = int(duration_match.group(1))
        
        # Extract date patterns - numeric formats
        date_patterns = [
            r'(\d{4}-\d{2}-\d{2})',  # YYYY-MM-DD
            r'(\d{4}/\d{2}/\d{2})',  # YYYY/MM/DD
            r'(\d{1,2}/\d{1,2}/\d{4})',  # MM/DD/YYYY
            r'(\d{1,2}-\d{1,2}-\d{4})',  # MM-DD-YYYY
        ]
        
        for pattern in date_patterns:
            date_match = re.search(pattern, query_lower)
            if date_match:
                start_date = date_match.group(1)
                # Convert YYYY/MM/DD to YYYY-MM-DD format
                if '/' in start_date and len(start_date.split('/')[0]) == 4:
                    # YYYY/MM/DD format
                    parts = start_date.split('/')
                    start_date = f"{parts[0]}-{parts[1]}-{parts[2]}"
                elif '/' in start_date:
                    # MM/DD/YYYY format
                    parts = start_date.split('/')
                    start_date = f"{parts[2]}-{parts[0]}-{parts[1]}"
                break
        
        # If no numeric date found, try natural language date parsing
        if not start_date:
            # Month names mapping
            month_names = {
                'january': '01', 'jan': '01',
                'february': '02', 'feb': '02',
                'march': '03', 'mar': '03',
                'april': '04', 'apr': '04',
                'may': '05',
                'june': '06', 'jun': '06',
                'july': '07', 'jul': '07',
                'august': '08', 'aug': '08',
                'september': '09', 'sep': '09', 'sept': '09',
                'october': '10', 'oct': '10',
                'november': '11', 'nov': '11',
                'december': '12', 'dec': '12'
            }
            
            # Pattern for "20th August 2025" or "August 20, 2025" or "August 20th 2025"
            natural_date_patterns = [
                r'(\d{1,2})(?:st|nd|rd|th)?\s+(' + '|'.join(month_names.keys()) + r')\s+(\d{4})',  # 20th August 2025
                r'(' + '|'.join(month_names.keys()) + r')\s+(\d{1,2})(?:st|nd|rd|th)?,?\s+(\d{4})',  # August 20, 2025
                r'(' + '|'.join(month_names.keys()) + r')\s+(\d{1,2})(?:st|nd|rd|th)?\s+(\d{4})',  # August 20th 2025
            ]
            
            for pattern in natural_date_patterns:
                date_match = re.search(pattern, query_lower)
                if date_match:
                    groups = date_match.groups()
                    if len(groups) == 3:
                        if groups[0].isdigit():
                            # Format: "20th August 2025"
                            day = groups[0].zfill(2)
                            month = month_names[groups[1]]
                            year = groups[2]
                        else:
                            # Format: "August 20, 2025"
                            month = month_names[groups[0]]
                            day = groups[1].zfill(2)
                            year = groups[2]
                        
                        start_date = f"{year}-{month}-{day}"
                        break
        
        # If no specific date found, try to infer from context
        if not start_date:
            if 'next week' in query_lower:
                start_date = (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d')
            elif 'next month' in query_lower:
                start_date = (datetime.now() + timedelta(days=30)).strftime('%Y-%m-%d')
            elif 'tomorrow' in query_lower:
                start_date = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')
        
        # Extract travelers count
        travelers = 1  # Default
        travelers_match = re.search(r'for\s+(\d+)\s+traveler', query_lower)
        if travelers_match:
            travelers = int(travelers_match.group(1))
        
        # Extract interests
        interests = []
        interest_keywords = [
            'food', 'art', 'history', 'nature', 'shopping', 'entertainment', 
            'beach', 'adventure', 'nightlife', 'architecture', 'culture', 'museums'
        ]
        for interest in interest_keywords:
            if interest in query_lower:
                interests.append(interest)
        
        # Extract budget preference
        budget_range = BudgetRange.MODERATE  # Default
        budget_keywords = {
            'budget': ['budget', 'cheap', 'affordable', 'economical', 'low cost', 'inexpensive'],
            'luxury': ['luxury', 'expensive', 'premium', 'high end', 'upscale', 'deluxe', 'fancy'],
            'moderate': ['moderate', 'medium', 'reasonable', 'mid range', 'standard']
        }
        
        # Check for keyword-based budget preferences
        for budget_type, keywords in budget_keywords.items():
            if any(keyword in query_lower for keyword in keywords):
                budget_range = BudgetRange(budget_type)
                break
        
        # If no keyword match, check for numeric amounts
        if budget_range == BudgetRange.MODERATE:  # Still default
            amount_match = re.search(r'(\d+)\s*\$?', query_lower)
            if amount_match:
                amount = int(amount_match.group(1))
                # Categorize based on amount ranges
                if amount <= 1000:
                    budget_range = BudgetRange.BUDGET
                elif amount <= 3000:
                    budget_range = BudgetRange.MODERATE
                else:
                    budget_range = BudgetRange.LUXURY
        
        # Create TripPlanningRequest with extracted information
        # Only set origin/destination if they were actually found
        trip_request = TripPlanningRequest(
            origin=origin if origin and origin != "Unknown" else None,
            destination=destination if destination and destination != "Unknown" else None, 
            duration_days=duration_days or 7,
            start_date=start_date,
            travelers=travelers,  # Use extracted travelers count
            trip_type=TripType.LEISURE,  # Default to leisure
            budget_range=budget_range,  # Use extracted budget preference
            interests=interests  # Use extracted interests
        )
        
        # Generate session ID
        session_id = str(uuid.uuid4())
        
        # Create session
        session = ai_planner.create_session(session_id)
        session.trip_request = trip_request
        session.current_step = "gathering_info"
        
        # Track which fields were provided in the initial request
        if origin and origin != "Unknown":
            session.provided_fields.append("origin")
        if destination and destination != "Unknown":
            session.provided_fields.append("destination")
        if duration_days:
            session.provided_fields.append("duration_days")
        if start_date:
            session.provided_fields.append("start_date")
        if travelers > 1:  # If travelers was specified (not default 1)
            session.provided_fields.append("travelers")
        if interests:  # If interests were specified
            session.provided_fields.append("interests")
        if budget_range != BudgetRange.MODERATE:  # If budget was specified (not default)
            session.provided_fields.append("budget_range")
        
        # Check if this is a comprehensive form submission (has all key details)
        is_comprehensive_submission = (
            origin and origin != "Unknown" and
            destination and destination != "Unknown" and
            duration_days and
            start_date and
            'interests' in user_query.lower() and
            'budget' in user_query.lower()
        )
        
        # Determine follow-up questions
        follow_up_questions = ai_planner.determine_follow_up_questions(trip_request, session)
        
        # Create acknowledgment message
        acknowledgment_parts = []
        if origin and origin != "Unknown":
            acknowledgment_parts.append(f"from {origin}")
        if destination and destination != "Unknown":
            acknowledgment_parts.append(f"to {destination}")
        if duration_days:
            acknowledgment_parts.append(f"for {duration_days} days")
        
        if acknowledgment_parts:
            acknowledgment = f"Great! I understand you want to plan a trip {' '.join(acknowledgment_parts)}."
        else:
            acknowledgment = "Great! I'd love to help you plan a trip."
        
        # If we have enough information OR this is a comprehensive form submission, generate itinerary
        if not follow_up_questions or is_comprehensive_submission:
            session.current_step = "generating_itinerary"
            itinerary = await ai_planner.generate_itinerary(trip_request)
            
            if "error" in itinerary:
                raise HTTPException(status_code=500, detail=itinerary["error"])
            
            session.itinerary = itinerary
            session.current_step = "itinerary_ready"
            
            return {
                "session_id": session_id,
                "status": "itinerary_ready",
                "itinerary": itinerary,
                "message": f"{acknowledgment} Your itinerary has been generated by our AI agent team!",
                "can_refine": True,
                "remaining_refinements": session.max_refinements,
                "agents_used": itinerary.get("agent_system", {}).get("agents_used", [])
            }
        
        # Return follow-up questions
        missing_count = len(follow_up_questions)
        if missing_count == 1:
            message = f"{acknowledgment} I just need one more detail to create your perfect itinerary."
        else:
            message = f"{acknowledgment} I need {missing_count} more details to create your perfect itinerary with our AI agents."
        
        return {
            "session_id": session_id,
            "status": "gathering_info",
            "follow_up_questions": [q.dict() for q in follow_up_questions],
            "message": message,
            "extracted_info": {
                "origin": origin,
                "destination": destination,
                "duration_days": duration_days,
                "start_date": start_date
            }
        }
        
    except Exception as e:
        logger.error(f"Error in natural language trip planning: {e}")
        raise HTTPException(status_code=500, detail=str(e)) 

@router.post("/comprehensive-plan")
async def create_comprehensive_trip_plan(request: Request):
    """
    Create a comprehensive trip plan with itinerary, flights, and hotels
    Flow: Itinerary → Flights → Hotels
    """
    try:
        body = await request.json()
        
        # Extract form data
        origin = body.get('origin', '')
        destination = body.get('destination', '')
        start_date = body.get('start_date', '')
        # Handle both end_date and return_date parameters
        return_date = body.get('return_date', '') or body.get('end_date', '')
        travelers = body.get('travelers', 1)
        budget_range = body.get('budget_range', 'moderate')
        trip_type = body.get('trip_type', 'leisure')
        interests = body.get('interests', [])
        
        # Validate required fields
        if not origin or not destination or not start_date or not return_date:
            raise HTTPException(status_code=400, detail="Missing required fields: origin, destination, start_date, and return_date/end_date are required")
        
        # Validate date format and calculate duration
        from datetime import datetime
        try:
            start_dt = datetime.strptime(start_date, '%Y-%m-%d')
            end_dt = datetime.strptime(return_date, '%Y-%m-%d')
            
            if start_dt >= end_dt:
                raise HTTPException(status_code=400, detail="Start date must be before return date")
                
            duration_days = (end_dt - start_dt).days + 1
        except ValueError as e:
            raise HTTPException(status_code=400, detail=f"Invalid date format. Use YYYY-MM-DD format. Error: {str(e)}")
        
        # Create trip planning request
        trip_request = TripPlanningRequest(
            origin=origin,
            destination=destination,
            duration_days=duration_days,
            start_date=start_date,
            end_date=return_date,
            travelers=travelers,
            trip_type=trip_type,
            budget_range=budget_range,
            interests=interests
        )
        
        # Step 1: Generate Itinerary
        logger.info("Step 1: Generating itinerary...")
        itinerary_result = await ai_planner.generate_itinerary(trip_request)
        
        if "error" in itinerary_result:
            raise HTTPException(status_code=500, detail=itinerary_result["error"])
        
        # Step 2: Search Flights
        logger.info("Step 2: Searching flights...")
        flight_results = await search_flights_comprehensive(origin, destination, start_date, return_date, travelers)
        
        # Step 3: Search Hotels
        logger.info("Step 3: Searching hotels...")
        hotel_results = await search_hotels_comprehensive(destination, start_date, return_date, travelers, budget_range)
        
        # Combine all results
        comprehensive_plan = {
            "trip_summary": {
                "origin": origin,
                "destination": destination,
                "start_date": start_date,
                "return_date": return_date,
                "duration_days": duration_days,
                "travelers": travelers,
                "budget_range": budget_range,
                "trip_type": trip_type
            },
            "itinerary": itinerary_result,
            "flights": flight_results,
            "hotels": hotel_results,
            "budget_breakdown": {
                "total_estimated_cost": 0,
                "flight_cost": 0,
                "hotel_cost": 0,
                "activities_cost": 0,
                "remaining_budget": 0
            }
        }
        
        # Calculate budget breakdown
        if flight_results.get("cheapest") and flight_results["cheapest"]:
            cheapest_flight = flight_results["cheapest"][0]
            if isinstance(cheapest_flight.get("price"), dict):
                comprehensive_plan["budget_breakdown"]["flight_cost"] = cheapest_flight["price"].get("amount", 0)
            else:
                comprehensive_plan["budget_breakdown"]["flight_cost"] = cheapest_flight.get("price", 0)
        
        # Calculate hotel cost from the hotel results
        if hotel_results and not hotel_results.get("error"):
            # Find the cheapest hotel across all categories
            all_hotels = []
            for category in ["budget", "mid_range", "luxury"]:
                if hotel_results.get(category):
                    all_hotels.extend(hotel_results[category])
            
            if all_hotels:
                # Find the cheapest hotel
                cheapest_hotel = min(all_hotels, key=lambda x: x.get("average_price_per_night", float('inf')))
                hotel_cost_per_night = cheapest_hotel.get("average_price_per_night", 0)
                comprehensive_plan["budget_breakdown"]["hotel_cost"] = hotel_cost_per_night * duration_days
        
        comprehensive_plan["budget_breakdown"]["total_estimated_cost"] = (
            comprehensive_plan["budget_breakdown"]["flight_cost"] +
            comprehensive_plan["budget_breakdown"]["hotel_cost"] +
            comprehensive_plan["budget_breakdown"]["activities_cost"]
        )
        
        return comprehensive_plan
        
    except HTTPException:
        # Re-raise HTTPExceptions as-is
        raise
    except Exception as e:
        logger.error(f"Comprehensive trip planning error: {e}")
        raise HTTPException(status_code=500, detail=f"Trip planning failed: {str(e)}")

async def search_flights_comprehensive(origin: str, destination: str, start_date: str, return_date: str, travelers: int):
    """Search flights and categorize into cheapest, fastest, and best value"""
    try:
        from api.booking_client import booking_client
        from api.enhanced_parser import EnhancedQueryParser
        
        # Clean city names (remove state abbreviations)
        origin_clean = origin.split(',')[0].strip()
        destination_clean = destination.split(',')[0].strip()
        
        # Get destination IDs
        parser = EnhancedQueryParser()
        origin_iata = parser._lookup_iata_code(origin_clean)
        dest_iata = parser._lookup_iata_code(destination_clean)
        
        if not origin_iata or not dest_iata:
            return {"error": f"Could not find airport codes for {origin_clean} or {destination_clean}"}
        
        # Search for destinations to get location IDs
        origin_search = booking_client.search_destination(origin_clean)
        dest_search = booking_client.search_destination(destination_clean)
        
        # Handle destination search errors
        if "error" in origin_search:
            logger.error(f"Origin destination search failed: {origin_search}")
            return {"error": f"Failed to search origin destination '{origin_clean}': {origin_search.get('message', 'Unknown error')}"}
        
        if "error" in dest_search:
            logger.error(f"Destination search failed: {dest_search}")
            return {"error": f"Failed to search destination '{destination_clean}': {dest_search.get('message', 'Unknown error')}"}
        
        if not origin_search.get('destinations'):
            return {"error": f"No destinations found for origin '{origin_clean}'. Please check the city name."}
        
        if not dest_search.get('destinations'):
            return {"error": f"No destinations found for destination '{destination_clean}'. Please check the city name."}
        
        origin_id = origin_search['destinations'][0].get('id')
        dest_id = dest_search['destinations'][0].get('id')
        
        if not origin_id or not dest_id:
            return {"error": f"Could not find location IDs for {origin_clean} or {destination_clean}"}
        
        # Search for flights
        flight_results = booking_client.search_flights(
            from_id=origin_id,
            to_id=dest_id,
            depart_date=start_date,
            return_date=return_date,
            adults=travelers,
            cabin_class="ECONOMY"
        )
        
        if "error" in flight_results:
            return {"error": f"Flight search failed: {flight_results['error']}"}
        
        # Process and categorize flights based on actual API response structure
        all_flights = []
        if flight_results.get('status') and flight_results.get('data'):
            # Check for flight offers in the response
            flight_offers = flight_results['data'].get('flightOffers', [])
            logger.info(f"Found {len(flight_offers)} flight offers")
            
            if not flight_offers:
                # Check if there are flights in a different field
                if flight_results['data'].get('flights'):
                    flight_offers = flight_results['data']['flights']
                elif isinstance(flight_results['data'], list):
                    flight_offers = flight_results['data']
                else:
                    # Check aggregation data
                    if 'aggregation' in flight_results['data']:
                        total_count = flight_results['data']['aggregation'].get('totalCount', 0)
                        if total_count > 0:
                            return {"error": f"Found {total_count} flights but they require pagination. Please try a different search or contact support."}
                    
                    return {"error": f"No flights found from {origin_clean} to {destination_clean} for the specified dates. Try different dates or check if the route is available."}
            
            logger.info(f"Processing {len(flight_offers)} flight offers")
            for i, flight_offer in enumerate(flight_offers):
                try:
                    # Extract basic flight info
                    token = flight_offer.get('token', '')
                    segments = flight_offer.get('segments', [])
                    price_breakdown = flight_offer.get('priceBreakdown', {})
                    
                    logger.info(f"Flight offer {i+1}: segments={len(segments)}, has_price_breakdown={'priceBreakdown' in flight_offer}")
                    
                    if not segments:
                        logger.warning(f"Flight offer {i+1} has no segments")
                        continue
                    
                    # Process outbound segment (first segment)
                    outbound_segment = segments[0]
                    outbound_legs = outbound_segment.get('legs', [])
                    
                    if not outbound_legs:
                        continue
                    
                    outbound_leg = outbound_legs[0]
                    
                    # Extract airline info
                    carriers_data = outbound_leg.get('carriersData', [])
                    airline_name = carriers_data[0].get('name', 'Unknown') if carriers_data else 'Unknown'
                    
                    # Extract flight times
                    departure_time = outbound_leg.get('departureTime', '')
                    arrival_time = outbound_leg.get('arrivalTime', '')
                    
                    # Convert duration from seconds to hours and minutes
                    total_time_seconds = outbound_leg.get('totalTime', 0)
                    hours = total_time_seconds // 3600
                    minutes = (total_time_seconds % 3600) // 60
                    duration_str = f"{hours}h {minutes}m" if minutes > 0 else f"{hours}h"
                    
                    # Extract price info
                    total_price = price_breakdown.get('total', {})
                    price_amount = total_price.get('units', 0) + (total_price.get('nanos', 0) / 1_000_000_000)
                    currency = total_price.get('currencyCode', 'USD')
                    
                    # Count stops
                    flight_stops = outbound_leg.get('flightStops', [])
                    stops_count = len(flight_stops)
                    
                    formatted_flight = {
                        "token": token,
                        "airline": airline_name,
                        "departure_time": departure_time,
                        "arrival_time": arrival_time,
                        "duration": duration_str,
                        "duration_minutes": total_time_seconds // 60,  # For sorting
                        "stops": stops_count,
                        "price": price_amount,
                        "currency": currency
                    }
                    all_flights.append(formatted_flight)
                    
                except Exception as e:
                    logger.error(f"Error processing flight offer: {e}")
                    continue
        
        logger.info(f"Successfully processed {len(all_flights)} flights")
        
        if not all_flights:
            logger.error("No flights were processed successfully")
            return {"error": f"No flights found from {origin_clean} to {destination_clean} for the specified dates. Try different dates or check if the route is available."}
        
        # Categorize flights
        cheapest = sorted(all_flights, key=lambda x: x["price"] if isinstance(x["price"], (int, float)) else float('inf'))[:3]
        fastest = sorted(all_flights, key=lambda x: x["duration_minutes"] if isinstance(x["duration_minutes"], (int, float)) else float('inf'))[:3]
        
        # Best value (combination of price and duration)
        def calculate_value_score(flight):
            price = flight["price"] if isinstance(flight["price"], (int, float)) else float('inf')
            duration_minutes = flight["duration_minutes"] if isinstance(flight["duration_minutes"], (int, float)) else float('inf')
            if price == float('inf') or duration_minutes == float('inf'):
                return float('inf')
            return (price * 0.7) + (duration_minutes * 0.3)
        
        best_value = sorted(all_flights, key=calculate_value_score)[:3]
        
        result = {
            "cheapest": cheapest,
            "fastest": fastest,
            "best_value": best_value,
            "total_flights_found": len(all_flights)
        }
        
        logger.info(f"Returning flight results: {len(cheapest)} cheapest, {len(fastest)} fastest, {len(best_value)} best value")
        return result
        
    except Exception as e:
        logger.error(f"Flight search error: {e}")
        return {"error": f"Flight search failed: {str(e)}"}

async def search_hotels_comprehensive(destination: str, start_date: str, return_date: str, travelers: int, budget_range: str):
    """Enhanced hotel search with smart budget handling and destination fallback"""
    try:
        from api.hotel_client import HotelClient
        from api.models import HotelSearchRequest
        
        hotel_client = HotelClient()
        
        # Calculate max budget based on budget range
        max_budget = None
        if budget_range == "budget":
            max_budget = 150  # Budget hotels under $150/night
        elif budget_range == "moderate":
            max_budget = 300  # Moderate hotels under $300/night
        elif budget_range == "luxury":
            max_budget = 500  # Luxury hotels under $500/night
        
        # Create hotel search request
        hotel_request = HotelSearchRequest(
            location=destination,
            check_in=start_date,
            check_out=return_date,
            adults=travelers,
            children=[],
            rooms=1,
            currency="USD",
            language="en-us",
            page_number=1
        )
        
        # Use smart hotel search with budget handling
        hotel_results = hotel_client.smart_hotel_search(
            request=hotel_request,
            max_budget=max_budget,
            budget_expansion_steps=3
        )
        
        if hotel_results.search_metadata and "error" in hotel_results.search_metadata:
            return {"error": f"Hotel search failed: {hotel_results.search_metadata['error']}"}
        
        if hotel_results.total_results == 0:
            return {"error": "No hotels found for the specified criteria"}
        
        # Process and categorize hotels by price
        budget_hotels = []
        moderate_hotels = []
        luxury_hotels = []
        
        for hotel_result in hotel_results.hotels:
            hotel = hotel_result.hotel
            price_per_night = hotel_result.average_price_per_night or 0
            currency = hotel_result.currency or "USD"
            
            # Convert price to USD for categorization using dynamic currency converter
            price_usd = price_per_night
            if currency != "USD":
                from api.currency_converter import currency_converter
                try:
                    converted_price = await currency_converter.convert_price(price_per_night, currency, "USD")
                    if converted_price is not None:
                        price_usd = converted_price
                    else:
                        logger.error(f"Currency conversion failed for {currency} to USD")
                        # If conversion fails, skip this hotel to avoid incorrect categorization
                        continue
                except Exception as e:
                    logger.error(f"Currency conversion error for {currency}: {e}")
                    # If conversion fails, skip this hotel to avoid incorrect categorization
                    continue
            
            hotel_data = {
                "hotel_id": hotel.hotel_id,
                "name": hotel.name,
                "rating": hotel.rating,
                "review_score": hotel.review_score,
                "star_rating": hotel.star_rating,
                "average_price_per_night": price_per_night,
                "total_price": hotel_result.total_price,
                "currency": currency,
                "photos": hotel.photos,
                "address": hotel.address,
                "city": hotel.city,
                "country": hotel.country,
                "property_type": hotel.property_type,
                "amenities": hotel.amenities
            }
            
            # Categorize by star rating AND price (using USD equivalent)
            star_rating = hotel.star_rating or 0
            
            # Determine category based on star rating first, then price
            if star_rating <= 2:
                # 1-2 stars = Budget
                budget_hotels.append(hotel_data)
            elif star_rating == 3:
                # 3 stars = Moderate/Medium
                moderate_hotels.append(hotel_data)
            elif star_rating >= 4:
                # 4-5 stars = Luxury
                luxury_hotels.append(hotel_data)
            else:
                # If no star rating, categorize by price as fallback
                if destination.lower() in ['india', 'tirupati', 'hyderabad', 'delhi', 'mumbai', 'bangalore']:
                    # Lower price ranges for Indian destinations
                    budget_threshold = 50
                    moderate_threshold = 150
                else:
                    # Standard price ranges for other destinations
                    budget_threshold = 150
                    moderate_threshold = 300
                
                if price_usd <= budget_threshold:
                    budget_hotels.append(hotel_data)
                elif price_usd <= moderate_threshold:
                    moderate_hotels.append(hotel_data)
                else:
                    luxury_hotels.append(hotel_data)
        
        # Generate booking URLs for top hotels in each category
        booking_urls = {}
        for hotel in (budget_hotels[:2] + moderate_hotels[:2] + luxury_hotels[:2]):
            booking_url = hotel_client.generate_hotel_booking_url(
                hotel_id=hotel["hotel_id"],
                check_in=start_date,
                check_out=return_date,
                adults=travelers,
                children=[],
                rooms=1,
                currency="USD"
            )
            booking_urls[hotel["hotel_id"]] = booking_url
        
        # Smart search metadata
        search_metadata = {
            "total_results": hotel_results.total_results,
            "currency": "USD",
            "smart_search": True,
            "search_attempts": hotel_results.search_metadata.get("search_attempts", 0),
            "destinations_tried": hotel_results.search_metadata.get("destinations_tried", 0),
            "budget_expansion_used": max_budget is not None,
            "max_budget_applied": max_budget
        }
        
        # Return categorized results
        return {
            "budget": budget_hotels[:3],
            "moderate": moderate_hotels[:3],
            "luxury": luxury_hotels[:3],
            "total_hotels_found": len(hotel_results.hotels),
            "booking_urls": booking_urls,
            "search_metadata": search_metadata,
            "message": f"Smart search found {len(hotel_results.hotels)} hotels across {hotel_results.search_metadata.get('destinations_tried', 0)} destinations"
        }
        
    except Exception as e:
        logger.error(f"Hotel search error: {e}")
        return {"error": f"Hotel search failed: {str(e)}"} 

async def search_flights_with_filters(
    origin: str, 
    destination: str, 
    start_date: str, 
    return_date: str, 
    travelers: int,
    filters: dict = None
):
    """Enhanced flight search with inline filters"""
    try:
        from api.booking_client import booking_client
        from api.enhanced_parser import EnhancedQueryParser
        
        # Set default filters if none provided
        if filters is None:
            filters = {}
        
        # Extract filter parameters
        non_stop_only = filters.get('non_stop_only', False)
        preferred_airlines = filters.get('preferred_airlines', [])
        cabin_class = filters.get('cabin_class', 'ECONOMY')
        departure_time_pref = filters.get('departure_time_pref', [])  # ['morning', 'afternoon', 'evening']
        max_price = filters.get('max_price', None)
        max_duration = filters.get('max_duration', None)  # in minutes
        baggage_included = filters.get('baggage_included', False)
        refundable_only = filters.get('refundable_only', False)
        
        # Clean city names
        origin_clean = origin.split(',')[0].strip()
        destination_clean = destination.split(',')[0].strip()
        
        # Get destination IDs
        parser = EnhancedQueryParser()
        origin_iata = parser._lookup_iata_code(origin_clean)
        dest_iata = parser._lookup_iata_code(destination_clean)
        
        if not origin_iata or not dest_iata:
            return {"error": f"Could not find airport codes for {origin_clean} or {destination_clean}"}
        
        # Search for destinations to get location IDs
        origin_search = booking_client.search_destination(origin_clean)
        dest_search = booking_client.search_destination(destination_clean)
        
        if "error" in origin_search or "error" in dest_search:
            return {"error": "Destination search failed"}
        
        origin_id = origin_search['destinations'][0].get('id')
        dest_id = dest_search['destinations'][0].get('id')
        
        # Search for flights
        flight_results = booking_client.search_flights(
            from_id=origin_id,
            to_id=dest_id,
            depart_date=start_date,
            return_date=return_date,
            adults=travelers,
            cabin_class=cabin_class
        )
        
        if "error" in flight_results:
            return {"error": f"Flight search failed: {flight_results['error']}"}
        
        # Process flights with filters
        all_flights = []
        if flight_results.get('status') and flight_results.get('data'):
            flight_offers = flight_results['data'].get('flightOffers', [])
            
            if not flight_offers:
                return {"error": f"No flights found from {origin_clean} to {destination_clean}"}
            
            for flight_offer in flight_offers:
                try:
                    # Extract basic flight info
                    token = flight_offer.get('token', '')
                    segments = flight_offer.get('segments', [])
                    price_breakdown = flight_offer.get('priceBreakdown', {})
                    
                    if not segments:
                        continue
                    
                    # Process outbound segment
                    outbound_segment = segments[0]
                    outbound_legs = outbound_segment.get('legs', [])
                    
                    if not outbound_legs:
                        continue
                    
                    outbound_leg = outbound_legs[0]
                    
                    # Extract airline info
                    carriers_data = outbound_leg.get('carriersData', [])
                    airline_name = carriers_data[0].get('name', 'Unknown') if carriers_data else 'Unknown'
                    airline_code = carriers_data[0].get('code', '') if carriers_data else ''
                    
                    # Extract flight times
                    departure_time = outbound_leg.get('departureTime', '')
                    arrival_time = outbound_leg.get('arrivalTime', '')
                    
                    # Parse departure time for filtering
                    from datetime import datetime
                    try:
                        dep_time = datetime.fromisoformat(departure_time.replace('Z', '+00:00'))
                        hour = dep_time.hour
                        if 6 <= hour < 12:
                            time_period = 'morning'
                        elif 12 <= hour < 18:
                            time_period = 'afternoon'
                        else:
                            time_period = 'evening'
                    except:
                        time_period = 'unknown'
                    
                    # Calculate duration
                    total_time_seconds = outbound_leg.get('totalTime', 0)
                    duration_minutes = total_time_seconds // 60
                    duration_str = f"{duration_minutes // 60}h {duration_minutes % 60}m"
                    
                    # Extract price info
                    total_price = price_breakdown.get('total', {})
                    price_amount = total_price.get('units', 0) + (total_price.get('nanos', 0) / 1_000_000_000)
                    currency = total_price.get('currencyCode', 'USD')
                    
                    # Count stops
                    flight_stops = outbound_leg.get('flightStops', [])
                    stops_count = len(flight_stops)
                    
                    # Apply filters
                    if non_stop_only and stops_count > 0:
                        continue
                    
                    if preferred_airlines and airline_code not in preferred_airlines:
                        continue
                    
                    if departure_time_pref and time_period not in departure_time_pref:
                        continue
                    
                    if max_price and price_amount > max_price:
                        continue
                    
                    if max_duration and duration_minutes > max_duration:
                        continue
                    
                    # Extract baggage info (if available)
                    baggage_info = outbound_leg.get('baggage', {})
                    has_baggage = baggage_info.get('included', False) if baggage_info else False
                    
                    if baggage_included and not has_baggage:
                        continue
                    
                    # Extract refundable info (if available)
                    fare_info = flight_offer.get('fareInfo', {})
                    is_refundable = fare_info.get('refundable', False) if fare_info else False
                    
                    if refundable_only and not is_refundable:
                        continue
                    
                    formatted_flight = {
                        "token": token,
                        "airline": airline_name,
                        "airline_code": airline_code,
                        "departure_time": departure_time,
                        "arrival_time": arrival_time,
                        "time_period": time_period,
                        "duration": duration_str,
                        "duration_minutes": duration_minutes,
                        "stops": stops_count,
                        "price": price_amount,
                        "currency": currency,
                        "cabin_class": cabin_class,
                        "has_baggage": has_baggage,
                        "is_refundable": is_refundable,
                        "booking_url": f"https://booking.com/flights?token={token}"
                    }
                    all_flights.append(formatted_flight)
                    
                except Exception as e:
                    logger.error(f"Error processing flight offer: {e}")
                    continue
        
        if not all_flights:
            return {"error": "No flights match your filter criteria"}
        
        # Sort and categorize flights
        cheapest = sorted(all_flights, key=lambda x: x["price"])[:3]
        fastest = sorted(all_flights, key=lambda x: x["duration_minutes"])[:3]
        
        # Best value calculation
        def calculate_value_score(flight):
            price = flight["price"]
            duration = flight["duration_minutes"]
            return (price * 0.7) + (duration * 0.3)
        
        best_value = sorted(all_flights, key=calculate_value_score)[:3]
        
        # Apply additional sorting based on filters
        if preferred_airlines:
            # Sort preferred airlines first
            def airline_priority(flight):
                return flight["airline_code"] not in preferred_airlines
            
            cheapest = sorted(cheapest, key=airline_priority)
            fastest = sorted(fastest, key=airline_priority)
            best_value = sorted(best_value, key=airline_priority)
        
        result = {
            "cheapest": cheapest,
            "fastest": fastest,
            "best_value": best_value,
            "total_flights_found": len(all_flights),
            "filters_applied": filters,
            "search_metadata": {
                "origin": origin_clean,
                "destination": destination_clean,
                "dates": f"{start_date} to {return_date}",
                "travelers": travelers
            }
        }
        
        return result
        
    except Exception as e:
        logger.error(f"Enhanced flight search error: {e}")
        return {"error": f"Flight search failed: {str(e)}"} 

@router.post("/search-flights-enhanced")
async def search_flights_enhanced(request: dict):
    """Enhanced flight search with inline filters"""
    try:
        # Extract search parameters
        origin = request.get('origin', '')
        destination = request.get('destination', '')
        start_date = request.get('start_date', '')
        return_date = request.get('return_date', '')
        travelers = request.get('travelers', 1)
        filters = request.get('filters', {})
        
        # Validate required parameters
        if not all([origin, destination, start_date, return_date]):
            return {"error": "Missing required parameters: origin, destination, start_date, return_date"}
        
        # Call enhanced flight search
        result = await search_flights_with_filters(
            origin=origin,
            destination=destination,
            start_date=start_date,
            return_date=return_date,
            travelers=travelers,
            filters=filters
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Enhanced flight search endpoint error: {e}")
        return {"error": f"Flight search failed: {str(e)}"} 

async def search_hotels_with_filters(
    destination: str, 
    start_date: str, 
    return_date: str, 
    travelers: int,
    filters: dict = None
):
    """Enhanced hotel search with inline filters"""
    try:
        from api.hotel_client import HotelClient
        from api.models import HotelSearchRequest
        
        # Set default filters if none provided
        if filters is None:
            filters = {}
        
        # Extract filter parameters
        amenities = filters.get('amenities', [])  # ['breakfast', 'wifi', 'pool', 'gym', 'parking']
        location_pref = filters.get('location_pref', [])  # ['city_center', 'airport', 'beachfront']
        property_type = filters.get('property_type', [])  # ['hotel', 'resort', 'apartment']
        min_rating = filters.get('min_rating', 0)
        max_price = filters.get('max_price', None)
        min_price = filters.get('min_price', None)
        
        hotel_client = HotelClient()
        
        # Create hotel search request
        hotel_request = HotelSearchRequest(
            location=destination,
            check_in=start_date,
            check_out=return_date,
            adults=travelers,
            children=[],
            rooms=1,
            currency="USD",
            language="en-us",
            page_number=1
        )
        
        # Use smart hotel search
        hotel_results = hotel_client.smart_hotel_search(
            request=hotel_request,
            max_budget=max_price,
            budget_expansion_steps=3
        )
        
        if hotel_results.search_metadata and "error" in hotel_results.search_metadata:
            return {"error": f"Hotel search failed: {hotel_results.search_metadata['error']}"}
        
        if hotel_results.total_results == 0:
            return {"error": "No hotels found for the specified criteria"}
        
        # Process and categorize hotels with filters
        budget_hotels = []
        moderate_hotels = []
        luxury_hotels = []
        
        for hotel_result in hotel_results.hotels:
            hotel = hotel_result.hotel
            price_per_night = hotel_result.average_price_per_night or 0
            currency = hotel_result.currency or "USD"
            
            # Convert price to USD for categorization
            price_usd = price_per_night
            if currency != "USD":
                from api.currency_converter import currency_converter
                try:
                    converted_price = await currency_converter.convert_price(price_per_night, currency, "USD")
                    if converted_price is not None:
                        price_usd = converted_price
                    else:
                        continue
                except Exception as e:
                    logger.error(f"Currency conversion error: {e}")
                    continue
            
            # Apply price filters
            if max_price and price_usd > max_price:
                continue
            
            if min_price and price_usd < min_price:
                continue
            
            # Apply rating filter
            if min_rating and hotel.rating < min_rating:
                continue
            
            # Apply property type filter
            if property_type and hotel.property_type not in property_type:
                continue
            
            # Apply amenities filter (if available)
            hotel_amenities = hotel.amenities or []
            if amenities:
                # Check if hotel has required amenities
                has_required_amenities = True
                for amenity in amenities:
                    amenity_lower = amenity.lower()
                    if not any(amenity_lower in existing_amenity.lower() for existing_amenity in hotel_amenities):
                        has_required_amenities = False
                        break
                
                if not has_required_amenities:
                    continue
            
            # Apply location filter (if available)
            if location_pref:
                # This would require additional location data from the API
                # For now, we'll skip location filtering
                pass
            
            hotel_data = {
                "hotel_id": hotel.hotel_id,
                "name": hotel.name,
                "rating": hotel.rating,
                "review_score": hotel.review_score,
                "star_rating": hotel.star_rating,
                "average_price_per_night": price_per_night,
                "total_price": hotel_result.total_price,
                "currency": currency,
                "photos": hotel.photos,
                "address": hotel.address,
                "city": hotel.city,
                "country": hotel.country,
                "property_type": hotel.property_type,
                "amenities": hotel_amenities,
                "booking_url": hotel.booking_url
            }
            
            # Categorize by star rating
            star_rating = hotel.star_rating or 0
            
            if star_rating <= 2:
                budget_hotels.append(hotel_data)
            elif star_rating == 3:
                moderate_hotels.append(hotel_data)
            elif star_rating >= 4:
                luxury_hotels.append(hotel_data)
            else:
                # Fallback to price-based categorization
                if destination.lower() in ['india', 'tirupati', 'hyderabad', 'delhi', 'mumbai', 'bangalore']:
                    budget_threshold = 50
                    moderate_threshold = 150
                else:
                    budget_threshold = 150
                    moderate_threshold = 300
                
                if price_usd <= budget_threshold:
                    budget_hotels.append(hotel_data)
                elif price_usd <= moderate_threshold:
                    moderate_hotels.append(hotel_data)
                else:
                    luxury_hotels.append(hotel_data)
        
        # Generate booking URLs for top hotels in each category
        booking_urls = {}
        for hotel in (budget_hotels[:2] + moderate_hotels[:2] + luxury_hotels[:2]):
            booking_url = hotel_client.generate_hotel_booking_url(
                hotel_id=hotel["hotel_id"],
                check_in=start_date,
                check_out=return_date,
                adults=travelers,
                children=[],
                rooms=1,
                currency="USD"
            )
            booking_urls[hotel["hotel_id"]] = booking_url
        
        # Search metadata
        search_metadata = {
            "total_results": hotel_results.total_results,
            "currency": "USD",
            "smart_search": True,
            "search_attempts": hotel_results.search_metadata.get("search_attempts", 0),
            "destinations_tried": hotel_results.search_metadata.get("destinations_tried", 0),
            "filters_applied": filters
        }
        
        return {
            "budget": budget_hotels[:3],
            "moderate": moderate_hotels[:3],
            "luxury": luxury_hotels[:3],
            "total_hotels_found": len(budget_hotels) + len(moderate_hotels) + len(luxury_hotels),
            "booking_urls": booking_urls,
            "search_metadata": search_metadata,
            "filters_applied": filters
        }
        
    except Exception as e:
        logger.error(f"Enhanced hotel search error: {e}")
        return {"error": f"Hotel search failed: {str(e)}"} 

@router.post("/search-hotels-enhanced")
async def search_hotels_enhanced(request: dict):
    """Enhanced hotel search with inline filters"""
    try:
        # Extract search parameters
        destination = request.get('destination', '')
        start_date = request.get('start_date', '')
        return_date = request.get('return_date', '')
        travelers = request.get('travelers', 1)
        filters = request.get('filters', {})
        
        # Validate required parameters
        if not all([destination, start_date, return_date]):
            return {"error": "Missing required parameters: destination, start_date, return_date"}
        
        # Call enhanced hotel search
        result = await search_hotels_with_filters(
            destination=destination,
            start_date=start_date,
            return_date=return_date,
            travelers=travelers,
            filters=filters
        )
        
        return result
        
    except Exception as e:
        logger.error(f"Enhanced hotel search endpoint error: {e}")
        return {"error": f"Hotel search failed: {str(e)}"} 