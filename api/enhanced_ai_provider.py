import os
import json
import logging
import re
import calendar
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import anthropic
from dotenv import load_dotenv

from .trip_planner_interface import (
    TripPlannerProvider, 
    TripPlanRequest, 
    TripPlanResponse, 
    TripPlanMetadata,
    ProviderType, 
    TripPlanQuality
)
from .hotel_client import HotelClient
from .search_one_way import search_one_way_flights
from .models import HotelSearchRequest
from services.budget_allocation_service import BudgetAllocationService
from services.price_display_service import price_display_service
from services.location_detection_service import location_detection_service

load_dotenv()

logger = logging.getLogger(__name__)

class EnhancedAITripProvider(TripPlannerProvider):
    """Enhanced AI-powered trip planning provider using Claude with real API integration"""
    
    def __init__(self):
        self.client = anthropic.Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))
        self._available = bool(os.getenv("ANTHROPIC_API_KEY"))
        self.hotel_client = HotelClient()
        self.budget_service = BudgetAllocationService()
    
    def get_provider_type(self) -> ProviderType:
        return ProviderType.AI
    
    def get_quality_estimate(self) -> TripPlanQuality:
        return TripPlanQuality.EXCELLENT
    
    def is_available(self) -> bool:
        return self._available
    
    async def plan_trip(self, request: TripPlanRequest) -> TripPlanResponse:
        """Generate a comprehensive trip plan using AI with real API integration"""
        
        try:
            # Calculate budget allocation (30-35% for hotels)
            budget_allocation = self._calculate_budget_allocation(request)
            
            # Get real hotel data with budget constraints
            hotel_data = await self._get_hotel_recommendations(request, budget_allocation)
            
            # Get real flight data
            flight_data = await self._get_flight_recommendations(request)
            
            # Create enhanced AI prompt with real data and budget allocation
            prompt = self._create_enhanced_planning_prompt(request, hotel_data, flight_data, budget_allocation)
            
            # Call Claude
            response = await self._call_claude(prompt)
            
            # Parse the response
            itinerary = self._parse_ai_response(response)
            
            # Enhance with real booking links
            itinerary = self._enhance_with_real_booking_links(itinerary, hotel_data, flight_data, request)
            
            # Create metadata
            metadata = TripPlanMetadata(
                provider=ProviderType.AI,
                quality=TripPlanQuality.EXCELLENT,
                confidence_score=0.95,
                data_freshness="real_time",
                last_updated=datetime.now().isoformat(),
                source_notes=[
                    "Generated by Claude AI with real API integration",
                    "Includes real hotel availability and pricing",
                    "Flight recommendations based on actual search results",
                    "Booking links are personalized and functional"
                ]
            )
            
            # Add budget allocation to estimated costs
            estimated_costs = itinerary.get("estimated_costs", {})
            if budget_allocation:
                estimated_costs.update(budget_allocation.get("budget_breakdown", {}))
            
            return TripPlanResponse(
                success=True,
                itinerary=itinerary,
                metadata=metadata,
                booking_links=itinerary.get("booking_links", {}),
                estimated_costs=estimated_costs
            )
            
        except Exception as e:
            logger.error(f"Enhanced AI trip planning failed: {str(e)}")
            
            # Return a fallback response
            return TripPlanResponse(
                success=False,
                itinerary={
                    "trip_summary": {
                        "title": "Trip Planning",
                        "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
                        "highlights": ["Please retry", "Contact support if issue persists"]
                    },
                    "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                    "accommodation": {"moderate": []},
                    "itinerary": {},
                    "estimated_costs": {"total": "$0"},
                    "practical_info": {"currency": "USD", "language": "English"}
                },
                metadata=TripPlanMetadata(
                    provider=ProviderType.AI,
                    quality=TripPlanQuality.BASIC,
                    confidence_score=0.0,
                    data_freshness="unknown",
                    last_updated=datetime.now().isoformat(),
                    source_notes=["Fallback response due to API error"],
                    fallback_used=True
                ),
                error_message=f"AI planning service temporarily unavailable: {str(e)}"
            )
    
    async def _get_hotel_recommendations(self, request: TripPlanRequest, budget_allocation: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get real hotel recommendations using the hotel API with budget allocation"""
        try:
            # Require start_date to be provided
            if not request.start_date:
                logger.error("Start date is required for hotel search")
                return {"success": False, "hotels": [], "error": "Start date is required"}
            
            # Calculate check-in and check-out dates
            # Handle month-year format (e.g., "august 2025")
            if re.match(r'^[a-zA-Z]+\s+\d{4}$', request.start_date):
                # Convert "august 2025" to "2025-08-01"
                month_names = {name.lower(): i for i, name in enumerate(calendar.month_name) if name}
                parts = request.start_date.lower().split()
                if len(parts) == 2 and parts[0] in month_names:
                    month = month_names[parts[0]]
                    year = int(parts[1])
                    request.start_date = f"{year}-{month:02d}-01"
            
            start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
            end_date = start_date + timedelta(days=request.duration_days)
            
            # Create hotel search request
            hotel_request = HotelSearchRequest(
                location=request.destination,
                check_in=request.start_date,
                check_out=end_date.strftime("%Y-%m-%d"),
                adults=request.travelers,
                children=[],
                rooms=1,
                currency="USD"
            )
            
            # Use budget allocation for hotel search if available
            max_budget = None
            if budget_allocation and budget_allocation.get("hotel_budget_allocation"):
                hotel_budget = budget_allocation["hotel_budget_allocation"]
                per_night = float(hotel_budget["per_night"].replace("$", ""))
                max_budget = per_night * 1.2  # Allow 20% flexibility
            else:
                max_budget = self._get_budget_amount(request.budget_range)
            
            # Search for hotels
            hotel_response = self.hotel_client.smart_hotel_search(
                hotel_request, 
                max_budget=max_budget
            )
            
            if hotel_response.hotels and len(hotel_response.hotels) > 0:
                # Return top 8 hotels (minimum as requested)
                top_hotels = hotel_response.hotels[:8]
                
                # Detect user's currency and determine trip currency strategy
                user_location = await location_detection_service.detect_user_location()
                user_country = user_location.get("country_code", "US")
                user_currency = user_location.get("currency", "USD")
                
                # Determine origin and destination countries
                origin_country = await location_detection_service.get_country_from_city(request.origin)
                destination_country = await location_detection_service.get_country_from_city(request.destination)
                
                # Get currency strategy for this trip
                currency_strategy = location_detection_service.determine_trip_currency_strategy(
                    origin_country, destination_country, user_country
                )
                
                primary_currency = currency_strategy["primary_currency"]
                secondary_currency = currency_strategy["secondary_currency"]
                
                logger.info(f"Trip currency strategy: {currency_strategy}")
                
                hotels_with_prices = []
                for hotel in top_hotels:
                    if hotel.hotel and hotel.hotel.name:  # Check if hotel exists and has a name
                        hotels_with_prices.append({
                            "name": hotel.hotel.name,
                            "rating": hotel.hotel.rating,
                            "price_per_night": hotel.average_price_per_night,
                            "location": f"{hotel.hotel.city}, {hotel.hotel.country}",
                            "amenities": hotel.hotel.amenities or [],
                            "booking_link": self.hotel_client.generate_hotel_booking_url(
                                hotel.hotel.hotel_id,
                                request.start_date,
                                end_date.strftime("%Y-%m-%d"),
                                request.travelers,
                                [],
                                1,
                                "USD"
                            ),
                            "hotel_id": hotel.hotel.hotel_id
                        })
                
                # Convert prices to primary currency
                converted_hotels = await price_display_service.convert_hotel_prices(hotels_with_prices, primary_currency)
                
                return {
                    "success": True,
                    "hotels": converted_hotels,
                    "currency_strategy": currency_strategy,
                    "trip_info": {
                        "origin_country": origin_country,
                        "destination_country": destination_country,
                        "user_country": user_country,
                        "primary_currency": primary_currency,
                        "secondary_currency": secondary_currency
                    }
                }
            else:
                return {"success": False, "hotels": []}
                
        except Exception as e:
            logger.error(f"Hotel search failed: {str(e)}")
            return {"success": False, "hotels": []}
    
    async def _get_flight_recommendations(self, request: TripPlanRequest) -> Dict[str, Any]:
        """Get real flight recommendations using the flight API"""
        try:
            # Require start_date to be provided
            if not request.start_date:
                logger.error("Start date is required for flight search")
                return {"success": False, "flights": [], "error": "Start date is required"}
            
            # Calculate return date (for round trip)
            # Handle month-year format (e.g., "august 2025")
            if re.match(r'^[a-zA-Z]+\s+\d{4}$', request.start_date):
                # Convert "august 2025" to "2025-08-01"
                month_names = {name.lower(): i for i, name in enumerate(calendar.month_name) if name}
                parts = request.start_date.lower().split()
                if len(parts) == 2 and parts[0] in month_names:
                    month = month_names[parts[0]]
                    year = int(parts[1])
                    request.start_date = f"{year}-{month:02d}-01"
            
            start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
            return_date = start_date + timedelta(days=request.duration_days)
            
            # Use aiohttp to call the flight API directly
            import aiohttp
            import json
            
            # Prepare search parameters
            search_params = {
                "origin": request.origin,
                "destination": request.destination,
                "date": request.start_date,
                "return_date": return_date.strftime("%Y-%m-%d")
            }
            
            logger.info(f"Calling flight API with params: {search_params}")
            
            # Make request to the flight search endpoint
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    "http://localhost:8000/api/search",
                    json=search_params
                ) as response:
                    logger.info(f"Flight API response status: {response.status}")
                    
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Flight API response: {result}")
                        
                        if result.get("success") and result.get("flights"):
                            logger.info(f"Found {len(result['flights'])} flights")
                            
                            # Detect user's currency and determine trip currency strategy
                            user_location = await location_detection_service.detect_user_location()
                            user_country = user_location.get("country_code", "US")
                            user_currency = user_location.get("currency", "USD")
                            
                            # Determine origin and destination countries
                            origin_country = await location_detection_service.get_country_from_city(request.origin)
                            destination_country = await location_detection_service.get_country_from_city(request.destination)
                            
                            # Get currency strategy for this trip
                            currency_strategy = location_detection_service.determine_trip_currency_strategy(
                                origin_country, destination_country, user_country
                            )
                            
                            primary_currency = currency_strategy["primary_currency"]
                            secondary_currency = currency_strategy["secondary_currency"]
                            
                            logger.info(f"Flight trip currency strategy: {currency_strategy}")
                            
                            # Convert flight prices to primary currency
                            converted_flights = await price_display_service.convert_flight_prices(result["flights"], primary_currency)
                            
                            return {
                                "success": True,
                                "flights": converted_flights,
                                "categorized_flights": result.get("categorized_flights", {})
                            }
                        else:
                            logger.error(f"No flights found in response: {result}")
                            return {"success": False, "flights": []}
                    else:
                        error_text = await response.text()
                        logger.error(f"Flight API error: {error_text}")
                        return {"success": False, "flights": []}
                
        except Exception as e:
            logger.error(f"Flight search failed: {str(e)}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")
            return {"success": False, "flights": []}
    
    def _get_budget_amount(self, budget_range: str) -> Optional[float]:
        """Convert budget range to dollar amount"""
        if not budget_range:
            return 300  # Default moderate budget
            
        budget_range_lower = budget_range.lower()
        
        # Check for exact matches first
        budget_map = {
            "budget": 100,
            "moderate": 300,
            "luxury": 500
        }
        
        if budget_range_lower in budget_map:
            return budget_map[budget_range_lower]
        
        # Check for patterns like "Budget ($1000)" or "Luxury ($300+/day)"
        import re
        
        # Extract dollar amount from patterns like "($1000)" or "($300+)"
        dollar_pattern = r'\$(\d+(?:\+)?)'
        match = re.search(dollar_pattern, budget_range)
        if match:
            amount_str = match.group(1)
            if amount_str.endswith('+'):
                # For ranges like "$300+", use the base amount
                return float(amount_str[:-1])
            else:
                return float(amount_str)
        
        # Check for keywords in the string
        if "budget" in budget_range_lower:
            return 100
        elif "luxury" in budget_range_lower:
            return 500
        elif "moderate" in budget_range_lower:
            return 300
        
        # Default fallback
        return 300
    
    def _calculate_budget_allocation(self, request: TripPlanRequest) -> Dict[str, Any]:
        """Calculate budget allocation with 30-35% for hotels"""
        try:
            # Get total budget
            total_budget = self._get_budget_amount(request.budget_range)
            if not total_budget:
                total_budget = 300  # Default moderate budget
            
            # Calculate duration - handle None dates
            if not request.start_date or not request.end_date:
                # Use duration_days if available, otherwise default to 3 days
                duration = request.duration_days or 3
            else:
                start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
                end_date = datetime.strptime(request.end_date, "%Y-%m-%d")
                duration = (end_date - start_date).days
            
            # Calculate budget allocation
            allocation = self.budget_service.calculate_budget_allocation(
                total_budget=total_budget,
                trip_duration=duration,
                travelers=request.travelers
            )
            
            return allocation
            
        except Exception as e:
            logger.error(f"Error calculating budget allocation: {e}")
            return None
    
    def _create_enhanced_planning_prompt(self, request: TripPlanRequest, 
                                       hotel_data: Dict[str, Any], 
                                       flight_data: Dict[str, Any],
                                       budget_allocation: Dict[str, Any] = None) -> str:
        """Create an enhanced prompt with real API data and smart trip logic"""
        
        interests_text = ", ".join(request.interests) if request.interests else "general exploration"
        
        # 🚀 SMART TRIP LOGIC: Add intelligent planning context
        smart_trip_context = ""
        if hasattr(request, 'smart_trip_data') and request.smart_trip_data:
            smart_data = request.smart_trip_data
            trip_type = smart_data.get("trip_type")
            
            if trip_type == "national_park":
                airport = smart_data.get("recommended_airport", "nearest airport")
                transportation = smart_data.get("transportation_options", [])
                min_days = smart_data.get("minimum_days", 3)
                smart_trip_context = f"""
🚀 **SMART TRIP ANALYSIS - NATIONAL PARK ADVENTURE**
This is a national park trip requiring special planning:
- **Recommended Airport**: {airport} (closest major airport with best flight availability)
- **Transportation Required**: Rental car is essential for park exploration
- **Transportation Options**: {', '.join(transportation)}
- **Minimum Recommended Days**: {min_days} days for full experience
- **Special Considerations**: 
  * Plan for seasonal road conditions and park accessibility
  * Include driving time from airport to park entrance
  * Consider park shuttle services and parking
  * Plan for weather-dependent activities
"""
            
            elif trip_type == "multi_city":
                cities = smart_data.get("cities", [])
                route_type = smart_data.get("route_suggestion", {}).get("route_type", "Cultural Journey")
                transportation = smart_data.get("route_suggestion", {}).get("transportation", {})
                min_days = smart_data.get("minimum_days", 7)
                smart_trip_context = f"""
🚀 **SMART TRIP ANALYSIS - MULTI-CITY ADVENTURE**
This is a multi-city trip requiring route planning:
- **Route Type**: {route_type}
- **Cities**: {', '.join(cities)}
- **Transportation Between Cities**: High-speed trains and local transit
- **Minimum Recommended Days**: {min_days} days for full experience
- **Special Considerations**:
  * Plan efficient city-to-city travel routes
  * Consider luggage handling between cities
  * Include local transportation in each city
  * Plan for different cultural experiences in each location
"""
        
        # Format hotel data for the prompt based on budget allocation
        hotel_info = ""
        logger.info(f"Hotel data structure: {hotel_data}")
        if hotel_data.get("success") and hotel_data.get("hotels"):
            hotel_info = "\n**Real Hotel Options Available (Based on Budget Allocation):**\n"
            
            # Calculate budget-based hotel categories
            if budget_allocation and budget_allocation.get('hotel_budget_allocation'):
                allocated_amount = budget_allocation['hotel_budget_allocation'].get('allocated_amount', 0)
                # Convert to float if it's a string
                if isinstance(allocated_amount, str):
                    # Remove currency symbols and convert to float
                    allocated_amount = float(allocated_amount.replace('$', '').replace(',', ''))
                else:
                    allocated_amount = float(allocated_amount)
                
                duration = request.duration_days or 3
                nightly_budget = allocated_amount / duration if duration > 0 else allocated_amount / 3
                
                logger.info(f"Budget allocation: {allocated_amount}, Duration: {duration}, Nightly budget: {nightly_budget}")
                
                # Categorize hotels based on allocated budget
                budget_hotels = [h for h in hotel_data["hotels"] if h.get('price_per_night', 0) <= nightly_budget * 0.6 and h.get('name')]
                moderate_hotels = [h for h in hotel_data["hotels"] if nightly_budget * 0.6 < h.get('price_per_night', 0) <= nightly_budget * 1.2 and h.get('name')]
                luxury_hotels = [h for h in hotel_data["hotels"] if h.get('price_per_night', 0) > nightly_budget * 1.2 and h.get('name')]
                
                hotel_info += f"**Budget Hotels (Under ${nightly_budget * 0.6:.0f}/night - {len(budget_hotels)} available):**\n"
                for i, hotel in enumerate(budget_hotels[:8], 1):
                    hotel_info += f"{i}. {hotel.get('name', 'Hotel')} - ${hotel.get('price_per_night', 0)}/night, {hotel.get('rating', 'N/A')}★\n"
                    hotel_info += f"   Location: {hotel.get('location', 'N/A')}\n"
                    hotel_info += f"   Amenities: {', '.join(hotel.get('amenities', [])[:3])}\n\n"
                
                hotel_info += f"**Moderate Hotels (${nightly_budget * 0.6:.0f}-${nightly_budget * 1.2:.0f}/night - {len(moderate_hotels)} available):**\n"
                for i, hotel in enumerate(moderate_hotels[:8], 1):
                    hotel_info += f"{i}. {hotel.get('name', 'Hotel')} - ${hotel.get('price_per_night', 0)}/night, {hotel.get('rating', 'N/A')}★\n"
                    hotel_info += f"   Location: {hotel.get('location', 'N/A')}\n"
                    hotel_info += f"   Amenities: {', '.join(hotel.get('amenities', [])[:3])}\n\n"
                
                hotel_info += f"**Luxury Hotels (Above ${nightly_budget * 1.2:.0f}/night - {len(luxury_hotels)} available):**\n"
                for i, hotel in enumerate(luxury_hotels[:8], 1):
                    hotel_info += f"{i}. {hotel.get('name', 'Hotel')} - ${hotel.get('price_per_night', 0)}/night, {hotel.get('rating', 'N/A')}★\n"
                    hotel_info += f"   Location: {hotel.get('location', 'N/A')}\n"
                    hotel_info += f"   Amenities: {', '.join(hotel.get('amenities', [])[:3])}\n\n"
            else:
                # Fallback to fixed categories if no budget allocation
                hotel_info += "**Budget Hotels (Under $100/night):**\n"
                budget_hotels = [h for h in hotel_data["hotels"] if h.get('price_per_night', 0) < 100 and h.get('name')]
                for i, hotel in enumerate(budget_hotels[:6], 1):
                    hotel_info += f"{i}. {hotel.get('name', 'Hotel')} - ${hotel.get('price_per_night', 0)}/night, {hotel.get('rating', 'N/A')}★\n"
                    hotel_info += f"   Location: {hotel.get('location', 'N/A')}\n"
                    hotel_info += f"   Amenities: {', '.join(hotel.get('amenities', [])[:3])}\n\n"
                
                hotel_info += "**Moderate Hotels ($100-$400/night):**\n"
                moderate_hotels = [h for h in hotel_data["hotels"] if 100 <= h.get('price_per_night', 0) < 400 and h.get('name')]
                for i, hotel in enumerate(moderate_hotels[:6], 1):
                    hotel_info += f"{i}. {hotel.get('name', 'Hotel')} - ${hotel.get('price_per_night', 0)}/night, {hotel.get('rating', 'N/A')}★\n"
                    hotel_info += f"   Location: {hotel.get('location', 'N/A')}\n"
                    hotel_info += f"   Amenities: {', '.join(hotel.get('amenities', [])[:3])}\n\n"
                
                hotel_info += "**Luxury Hotels (Above $500/night):**\n"
                luxury_hotels = [h for h in hotel_data["hotels"] if h.get('price_per_night', 0) >= 500 and h.get('name')]
                for i, hotel in enumerate(luxury_hotels[:6], 1):
                    hotel_info += f"{i}. {hotel.get('name', 'Hotel')} - ${hotel.get('price_per_night', 0)}/night, {hotel.get('rating', 'N/A')}★\n"
                    hotel_info += f"   Location: {hotel.get('location', 'N/A')}\n"
                    hotel_info += f"   Amenities: {', '.join(hotel.get('amenities', [])[:3])}\n\n"
        
        # Format flight data for the prompt
        flight_info = ""
        if flight_data.get("success") and flight_data.get("flights"):
            flight_info = "\n**Real Flight Options Available:**\n"
            flight_info += "**Fastest Flights:**\n"
            # Sort by duration (integer in seconds)
            fastest_flights = sorted(flight_data["flights"], key=lambda x: x.get('duration', 0))[:3]
            for i, flight in enumerate(fastest_flights, 1):
                # Format duration from seconds to readable format
                duration_seconds = flight.get('duration', 0)
                duration_str = f"{duration_seconds // 3600}h{(duration_seconds % 3600) // 60}m" if isinstance(duration_seconds, int) else str(duration_seconds)
                # Get price value
                price = flight.get('price', {})
                price_value = price.get('units', 0) if isinstance(price, dict) else price
                
                flight_info += f"{i}. {flight['airline']} - ${price_value}\n"
                flight_info += f"   Departure: {flight['departure_time']} | Arrival: {flight['arrival_time']}\n"
                flight_info += f"   Duration: {duration_str} | Stops: {flight.get('stops', 0)}\n\n"
            
            flight_info += "**Cheapest Flights:**\n"
            # Sort by price (handle both dict and simple values)
            cheapest_flights = sorted(flight_data["flights"], key=lambda x: x.get('price', {}).get('units', 0) if isinstance(x.get('price'), dict) else x.get('price', 0))[:3]
            for i, flight in enumerate(cheapest_flights, 1):
                # Format duration from seconds to readable format
                duration_seconds = flight.get('duration', 0)
                duration_str = f"{duration_seconds // 3600}h{(duration_seconds % 3600) // 60}m" if isinstance(duration_seconds, int) else str(duration_seconds)
                # Get price value
                price = flight.get('price', {})
                price_value = price.get('units', 0) if isinstance(price, dict) else price
                
                flight_info += f"{i}. {flight['airline']} - ${price_value}\n"
                flight_info += f"   Departure: {flight['departure_time']} | Arrival: {flight['arrival_time']}\n"
                flight_info += f"   Duration: {duration_str} | Stops: {flight.get('stops', 0)}\n\n"
            
            flight_info += "**Optimal Flights (Best Value):**\n"
            # Sort by combination of price and duration
            def parse_duration(duration):
                """Parse duration string like '3h 13m' to minutes"""
                if isinstance(duration, int):
                    return duration
                if isinstance(duration, str):
                    # Parse format like "3h 13m" or "3h" or "13m"
                    hours = 0
                    minutes = 0
                    if 'h' in duration:
                        hours = int(duration.split('h')[0])
                    if 'm' in duration:
                        parts = duration.split('h')
                        if len(parts) > 1:
                            minutes = int(parts[1].split('m')[0])
                        else:
                            minutes = int(duration.split('m')[0])
                    return hours * 60 + minutes
                return 0
            
            optimal_flights = sorted(flight_data["flights"], key=lambda x: (x.get('price', {}).get('units', 0) if isinstance(x.get('price'), dict) else x.get('price', 0)) + parse_duration(x.get('duration', 0)))[:3]
            for i, flight in enumerate(optimal_flights, 1):
                # Format duration from seconds to readable format
                duration_seconds = flight.get('duration', 0)
                duration_str = f"{duration_seconds // 3600}h{(duration_seconds % 3600) // 60}m" if isinstance(duration_seconds, int) else str(duration_seconds)
                # Get price value
                price = flight.get('price', {})
                price_value = price.get('units', 0) if isinstance(price, dict) else price
                
                flight_info += f"{i}. {flight['airline']} - ${price_value}\n"
                flight_info += f"   Departure: {flight['departure_time']} | Arrival: {flight['arrival_time']}\n"
                flight_info += f"   Duration: {duration_str} | Stops: {flight.get('stops', 0)}\n\n"
        
        prompt = f"""
You are an expert travel planner. Create a comprehensive {request.duration_days}-day trip plan from {request.origin} to {request.destination}.

{smart_trip_context}

**CRITICAL REQUIREMENTS:**
1. The destination is {request.destination}. Do NOT change this destination or suggest alternatives.
2. The trip starts on {request.start_date} and lasts exactly {request.duration_days} days.
3. Generate exactly {request.duration_days} days of itinerary (day_1, day_2, day_3, etc.).
4. Use the exact start date {request.start_date} for day_1, then calculate subsequent days correctly.
5. Include SPECIFIC flight and hotel recommendations with real booking links.

**Trip Details:**
- Origin: {request.origin}
- Destination: {request.destination} (DO NOT CHANGE THIS)
- Duration: {request.duration_days} days
- Start Date: {request.start_date} (USE THIS EXACT DATE FOR DAY 1)
- Travelers: {request.travelers} person(s)
- Budget: {request.budget_range}
- Trip Type: {request.trip_type}
- Interests: {interests_text}
- Special Requirements: {request.special_requirements or "None"}

**Smart Budget Allocation (30-35% for Hotels):**
- Total Budget: {budget_allocation.get('total_estimated_cost', 'N/A') if budget_allocation else 'N/A'}
- Hotel Budget: {budget_allocation.get('budget_breakdown', {}).get('accommodation', 'N/A') if budget_allocation else 'N/A'} ({budget_allocation.get('budget_percentages', {}).get('accommodation', 'N/A') if budget_allocation else 'N/A'})
- Flight Budget: {budget_allocation.get('budget_breakdown', {}).get('flights', 'N/A') if budget_allocation else 'N/A'} ({budget_allocation.get('budget_percentages', {}).get('flights', 'N/A') if budget_allocation else 'N/A'})
- Meal Budget: {budget_allocation.get('budget_breakdown', {}).get('meals', 'N/A') if budget_allocation else 'N/A'} ({budget_allocation.get('budget_percentages', {}).get('meals', 'N/A') if budget_allocation else 'N/A'})
- Activity Budget: {budget_allocation.get('budget_breakdown', {}).get('activities', 'N/A') if budget_allocation else 'N/A'} ({budget_allocation.get('budget_percentages', {}).get('activities', 'N/A') if budget_allocation else 'N/A'})
- Hotel Recommendation: {budget_allocation.get('hotel_budget_allocation', {}).get('recommendation', 'N/A') if budget_allocation else 'N/A'}

{hotel_info}
{flight_info}

**Requirements:**
1. Create a detailed day-by-day itinerary for {request.destination} specifically
2. Include specific attractions, restaurants, and activities in {request.destination}
3. Provide realistic time allocations for each activity
4. Include transportation options between locations in {request.destination}
5. Include SPECIFIC flight recommendations with airline names, prices, and booking links
6. Include SPECIFIC hotel recommendations with names, prices, and booking links - IMPORTANT: Use the budget-based hotel categories provided above and include at least 8-10 hotels total across all categories based on the allocated budget
7. Generate REAL booking URLs for flights using Google Flights (e.g., https://www.google.com/travel/flights?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date})
8. Generate REAL booking URLs for hotels using Google Hotels (e.g., https://www.google.com/travel/hotels?q=Hotels%20in%20{request.destination}%20from%20{request.start_date}%20to%20{request.end_date})
9. Include estimated costs for each category
10. Add cultural tips and practical advice for {request.destination}

**Response Format (JSON):**
{{
    "trip_summary": {{
        "title": "Trip title",
        "overview": "Brief trip overview",
        "highlights": ["key highlights"],
        "best_time_to_visit": "When to visit",
        "weather_info": "Weather during trip dates",
        "start_date": "{request.start_date}",
        "end_date": "calculated based on start_date and {request.duration_days} days"
    }},
    "transportation": {{
        "fastest": [
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://www.google.com/travel/flights?q=Flights%20from%20{{origin}}%20to%20{{destination}}%20on%20{{date}}"
            }},
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }},
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }}
        ],
        "cheapest": [
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }},
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }},
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }}
        ],
        "optimal": [
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }},
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }},
            {{
                "airline": "Specific airline name",
                "flight_number": "Specific flight number",
                "departure_time": "HH:MM",
                "arrival_time": "HH:MM",
                "duration": "XhYm",
                "cost": 0,
                "booking_link": "https://booking.com/flights/{{origin}}-{{destination}}"
            }}
        ]
    }},
    "accommodation": {{
        "budget": [
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }},
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }},
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }}
        ],
        "moderate": [
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }},
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }},
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }}
        ],
        "luxury": [
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }},
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }},
            {{
                "name": "Specific hotel name",
                "type": "hotel",
                "price_per_night": 0,
                "location": "Specific location",
                "booking_link": "https://www.booking.com/hotel/{{hotel_id}}.html?checkin={{start_date}}&checkout={{end_date}}&adults={{travelers}}&rooms=1&currency=USD",
                "pros": ["Pro 1", "Pro 2"],
                "cons": ["Con 1", "Con 2"]
            }}
        ]
    }},
    "itinerary": {{
        "day_1": {{
            "date": "{request.start_date}",
            "theme": "arrival_exploration",
            "morning": {{
                "activity": "Activity name",
                "location": "Location",
                "duration": "2 hours",
                "cost": 25,
                "description": "Detailed description",
                "tips": ["practical tips"],
                "booking_link": "https://..."
            }},
            "lunch": {{
                "restaurant": "Restaurant name",
                "cuisine": "Cuisine type",
                "price_range": "budget/moderate/luxury",
                "cost": 30,
                "location": "Location",
                "description": "Why this restaurant",
                "reservation_link": "https://..."
            }},
            "afternoon": {{...}},
            "dinner": {{...}},
            "evening": {{...}}
        }},
        "day_2": {{
            "date": "next day after {request.start_date}",
            "theme": "cultural_exploration",
            "morning": {{...}},
            "lunch": {{...}},
            "afternoon": {{...}},
            "dinner": {{...}},
            "evening": {{...}}
        }},
        "day_3": {{...}},
        "day_4": {{...}},
        "day_5": {{...}}
        // Continue for all {request.duration_days} days
    }},
    "transportation": {{
        "arrival": {{
            "method": "flight",
            "airline": "Specific airline name",
            "flight_number": "AA123",
            "departure_time": "10:00 AM",
            "arrival_time": "2:00 PM",
            "duration": "4 hours",
            "cost": 200,
            "booking_link": "https://booking.com/flights/{request.origin}-{request.destination}"
        }},
        "local_transport": {{
            "recommendations": ["transport options"],
            "cost_per_day": 15
        }},
        "departure": {{
            "method": "flight",
            "airline": "Specific airline name",
            "flight_number": "AA124",
            "departure_time": "6:00 PM",
            "arrival_time": "10:00 PM",
            "duration": "4 hours",
            "cost": 200,
            "booking_link": "https://booking.com/flights/{request.destination}-{request.origin}"
        }}
    }},
    "estimated_costs": {{
        "accommodation": 1050,
        "transportation": 300,
        "activities": 400,
        "food": 600,
        "total": 2350
    }},
    "booking_links": {{
        "flights": "https://...",
        "hotels": "https://...",
        "activities": "https://..."
    }},
    "practical_info": {{
        "currency": "Local currency",
        "language": "Local language",
        "timezone": "Timezone",
        "emergency_numbers": ["numbers"],
        "cultural_tips": ["tips"],
        "packing_suggestions": ["items"]
    }}
}}

Make the plan realistic, detailed, and personalized to the traveler's interests and budget. Include specific names of places, realistic prices, and practical information.

**CRITICAL REQUIREMENTS:**
1. You must respond with ONLY valid JSON in the exact format specified above. Do not include any text before or after the JSON. Do not use markdown formatting.
2. Generate exactly {request.duration_days} days of itinerary starting from {request.start_date}.
3. Each day should have a unique theme and activities.
4. Use the exact start date {request.start_date} for day_1.
5. Calculate subsequent days correctly (day_2, day_3, etc.).
6. Use the REAL hotel and flight data provided above in your recommendations.
7. **MANDATORY**: Generate EXACTLY 3 different flight options for each category (fastest, cheapest, optimal) = 9 total flight options.
8. **MANDATORY**: Generate EXACTLY 3 different hotel options for each category (budget, moderate, luxury) = 9 total hotel options.
9. **MANDATORY**: Use the real hotel data from the API to populate the hotel categories properly.
10. **MANDATORY**: Use the real flight data from the API to populate the flight categories properly.
11. **MANDATORY**: Do not repeat the same option multiple times - each option must be unique.
"""
        
        return prompt
    
    async def _call_claude(self, prompt: str) -> str:
        """Call Claude API with the planning prompt"""
        
        try:
            response = self.client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=4000,
                temperature=0.7,
                messages=[
                    {
                        "role": "user",
                        "content": prompt
                    }
                ]
            )
            
            return response.content[0].text
            
        except Exception as e:
            logger.error(f"Claude API call failed: {str(e)}")
            # Return a fallback response instead of raising
            return self._generate_fallback_response()
    
    def _generate_fallback_response(self) -> str:
        """Generate a fallback response when Claude API is unavailable"""
        return """```json
{
  "trip_summary": {
    "title": "Trip Planning",
    "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
    "highlights": ["Please retry", "Contact support if issue persists"],
    "best_time_to_visit": "TBD",
    "weather_info": "TBD",
    "start_date": "TBD",
    "end_date": "TBD"
  },
  "transportation": {
    "fastest": [],
    "cheapest": [],
    "optimal": []
  },
  "accommodation": {
    "moderate": []
  },
  "itinerary": {},
  "estimated_costs": {
    "accommodation": "$0",
    "transportation": "$0",
    "meals": "$0",
    "activities": "$0",
    "total": "$0"
  },
  "practical_info": {
    "currency": "USD",
    "language": "English",
    "timezone": "TBD",
    "emergency_numbers": ["911"],
    "cultural_tips": ["Please retry"],
    "packing_suggestions": ["TBD"]
  }
}
```"""
    
    def _parse_ai_response(self, response: str) -> Dict[str, Any]:
        """Parse the AI response into structured data"""
        
        try:
            # Try to extract JSON from the response
            import re
            
            # Find JSON blocks
            json_pattern = r'```json\s*(.*?)\s*```'
            json_matches = re.findall(json_pattern, response, re.DOTALL)
            
            if json_matches:
                # Use the first JSON block
                json_str = json_matches[0]
            else:
                # Try to find JSON without markdown
                json_pattern = r'\{.*\}'
                json_matches = re.findall(json_pattern, response, re.DOTALL)
                if json_matches:
                    json_str = json_matches[0]
                else:
                    raise ValueError("No JSON found in response")
            
            # Parse the JSON
            itinerary = json.loads(json_str)
            
            # Ensure required fields exist
            if "itinerary" not in itinerary:
                itinerary["itinerary"] = {}
            
            return itinerary
            
        except Exception as e:
            logger.error(f"Failed to parse AI response: {str(e)}")
            logger.error(f"Response: {response}")
            raise e
    
    def _enhance_with_real_booking_links(self, itinerary: Dict[str, Any], 
                                       hotel_data: Dict[str, Any], 
                                       flight_data: Dict[str, Any],
                                       request: TripPlanRequest) -> Dict[str, Any]:
        """Enhance the AI-generated itinerary with real booking links and data"""
        
        # Always enhance booking links with Google links, regardless of API data
        logger.info("Enhancing booking links with Google Flights and Hotels links...")
        
        # Enhance flight booking links
        if itinerary.get("transportation"):
            for category in ["fastest", "cheapest", "optimal"]:
                if itinerary["transportation"].get(category):
                    for flight in itinerary["transportation"][category]:
                        # Generate Google Flights link for this specific flight
                        flight["booking_link"] = self._generate_flight_deep_link(
                            request.origin, 
                            request.destination, 
                            request.start_date, 
                            request.travelers, 
                            flight
                        )
        
        # Enhance hotel booking links
        if itinerary.get("accommodation"):
            # Calculate checkout date
            from datetime import datetime, timedelta
            start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
            checkout_date = start_date + timedelta(days=request.duration_days)
            checkout_date_str = checkout_date.strftime("%Y-%m-%d")
            
            for category in ["budget", "moderate", "luxury"]:
                if itinerary["accommodation"].get(category):
                    for hotel in itinerary["accommodation"][category]:
                        # Generate Google Hotels link for this specific hotel
                        hotel["booking_link"] = self._generate_hotel_deep_link(
                            hotel, 
                            request.destination,
                            request.start_date, 
                            checkout_date_str, 
                            request.travelers
                        )
        
        # Generate proper deep links for flights (if API data is available)
        if flight_data.get("success") and flight_data.get("flights"):
            # Use categorized flights from API if available
            if flight_data.get("categorized_flights"):
                logger.info("Using pre-categorized flights from API")
                categorized_flights = flight_data["categorized_flights"]
                
                # Replace AI-generated flights with real API data
                logger.info("Replacing AI-generated flights with real API data...")
                
                # Completely replace the transportation structure with categorized format
                itinerary["transportation"] = {
                    "fastest": [],
                    "cheapest": [],
                    "optimal": []
                }
                
                # Update fastest flights (limit to 3)
                for flight in categorized_flights.get("fastest", [])[:3]:
                    # Extract flight number from carriers or other fields
                    flight_number = flight.get("flight_number", "")
                    if not flight_number and flight.get("carriers"):
                        # Use the first carrier code as flight number if available
                        carriers = flight.get("carriers", [])
                        if carriers:
                            flight_number = carriers[0]
                    
                    flight_obj = {
                        "airline": flight.get("airline", "Unknown"),
                        "flight_number": flight_number,
                        "departure_time": flight.get("departure_time", ""),
                        "arrival_time": flight.get("arrival_time", ""),
                        "duration": f"{flight.get('duration', 0) // 3600}h{(flight.get('duration', 0) % 3600) // 60}m" if isinstance(flight.get('duration'), int) else flight.get('duration', ''),
                        "cost": flight.get("price", {}).get("units", 0) if isinstance(flight.get("price"), dict) else flight.get("price", 0),
                        "booking_link": self._generate_flight_deep_link(request.origin, request.destination, request.start_date, request.travelers, flight)
                    }
                    itinerary["transportation"]["fastest"].append(flight_obj)
                
                # Update cheapest flights (limit to 3)
                for flight in categorized_flights.get("cheapest", [])[:3]:
                    # Extract flight number from carriers or other fields
                    flight_number = flight.get("flight_number", "")
                    if not flight_number and flight.get("carriers"):
                        # Use the first carrier code as flight number if available
                        carriers = flight.get("carriers", [])
                        if carriers:
                            flight_number = carriers[0]
                    
                    flight_obj = {
                        "airline": flight.get("airline", "Unknown"),
                        "flight_number": flight_number,
                        "departure_time": flight.get("departure_time", ""),
                        "arrival_time": flight.get("arrival_time", ""),
                        "duration": f"{flight.get('duration', 0) // 3600}h{(flight.get('duration', 0) % 3600) // 60}m" if isinstance(flight.get('duration'), int) else flight.get('duration', ''),
                        "cost": flight.get("price", {}).get("units", 0) if isinstance(flight.get("price"), dict) else flight.get("price", 0),
                        "booking_link": self._generate_flight_deep_link(request.origin, request.destination, request.start_date, request.travelers, flight)
                    }
                    itinerary["transportation"]["cheapest"].append(flight_obj)
                
                # Update optimal flights (limit to 3)
                for flight in categorized_flights.get("optimal", [])[:3]:
                    # Extract flight number from carriers or other fields
                    flight_number = flight.get("flight_number", "")
                    if not flight_number and flight.get("carriers"):
                        # Use the first carrier code as flight number if available
                        carriers = flight.get("carriers", [])
                        if carriers:
                            flight_number = carriers[0]
                    
                    flight_obj = {
                        "airline": flight.get("airline", "Unknown"),
                        "flight_number": flight_number,
                        "departure_time": flight.get("departure_time", ""),
                        "arrival_time": flight.get("arrival_time", ""),
                        "duration": f"{flight.get('duration', 0) // 3600}h{(flight.get('duration', 0) % 3600) // 60}m" if isinstance(flight.get('duration'), int) else flight.get('duration', ''),
                        "cost": flight.get("price", {}).get("units", 0) if isinstance(flight.get("price"), dict) else flight.get("price", 0),
                        "booking_link": self._generate_flight_deep_link(request.origin, request.destination, request.start_date, request.travelers, flight)
                    }
                    itinerary["transportation"]["optimal"].append(flight_obj)
                
                logger.info(f"Replaced flights with {len(categorized_flights.get('fastest', []))} fastest, {len(categorized_flights.get('cheapest', []))} cheapest, {len(categorized_flights.get('optimal', []))} optimal flights")
            else:
                # Fallback to manual categorization
                logger.info("No pre-categorized flights, using manual categorization")
                all_flights = flight_data["flights"]
                if all_flights:
                    # Sort by duration for fastest
                    fastest_flights = sorted(all_flights, key=lambda x: x.get('duration', 0))[:3]
                    # Sort by price for cheapest
                    cheapest_flights = sorted(all_flights, key=lambda x: x.get('price', {}).get('units', 0) if isinstance(x.get('price'), dict) else x.get('price', 0))[:3]
                    # Sort by combination of price and duration for optimal
                    def parse_duration_for_sorting(duration):
                        """Parse duration string like '3h 13m' to minutes for sorting"""
                        if isinstance(duration, int):
                            return duration
                        if isinstance(duration, str):
                            # Parse format like "3h 13m" or "3h" or "13m"
                            hours = 0
                            minutes = 0
                            if 'h' in duration:
                                hours = int(duration.split('h')[0])
                            if 'm' in duration:
                                parts = duration.split('h')
                                if len(parts) > 1:
                                    minutes = int(parts[1].split('m')[0])
                                else:
                                    minutes = int(duration.split('m')[0])
                            return hours * 60 + minutes
                        return 0
                    
                    optimal_flights = sorted(all_flights, key=lambda x: (x.get('price', {}).get('units', 0) if isinstance(x.get('price'), dict) else x.get('price', 0)) + parse_duration_for_sorting(x.get('duration', 0)))[:3]
                    
                    # Replace AI-generated flights with real API data
                    logger.info("Replacing AI-generated flights with real API data...")
                    
                    # Completely replace the transportation structure with categorized format
                    itinerary["transportation"] = {
                        "fastest": [],
                        "cheapest": [],
                        "optimal": []
                    }
                    
                    # Update fastest flights
                    for i, flight in enumerate(fastest_flights):
                        if i < 5:  # Ensure we only add 5 flights
                            flight_obj = {
                                "airline": flight.get("airline", "Unknown"),
                                "flight_number": flight.get("flight_number", "Unknown"),
                                "departure_time": flight.get("departure_time", ""),
                                "arrival_time": flight.get("arrival_time", ""),
                                "duration": f"{flight.get('duration', 0) // 3600}h{(flight.get('duration', 0) % 3600) // 60}m",
                                "cost": flight.get("price", {}).get("units", 0) if isinstance(flight.get("price"), dict) else flight.get("price", 0),
                                "booking_link": self._generate_flight_deep_link(request.origin, request.destination, request.start_date, request.travelers, flight)
                            }
                            itinerary["transportation"]["fastest"].append(flight_obj)
                    
                    # Update cheapest flights
                    for i, flight in enumerate(cheapest_flights):
                        if i < 5:  # Ensure we only add 5 flights
                            flight_obj = {
                                "airline": flight.get("airline", "Unknown"),
                                "flight_number": flight.get("flight_number", "Unknown"),
                                "departure_time": flight.get("departure_time", ""),
                                "arrival_time": flight.get("arrival_time", ""),
                                "duration": f"{flight.get('duration', 0) // 3600}h{(flight.get('duration', 0) % 3600) // 60}m",
                                "cost": flight.get("price", {}).get("units", 0) if isinstance(flight.get("price"), dict) else flight.get("price", 0),
                                "booking_link": self._generate_flight_deep_link(request.origin, request.destination, request.start_date, request.travelers, flight)
                            }
                            itinerary["transportation"]["cheapest"].append(flight_obj)
                    
                    # Update optimal flights
                    for i, flight in enumerate(optimal_flights):
                        if i < 5:  # Ensure we only add 5 flights
                            flight_obj = {
                                "airline": flight.get("airline", "Unknown"),
                                "flight_number": flight.get("flight_number", "Unknown"),
                                "departure_time": flight.get("departure_time", ""),
                                "arrival_time": flight.get("arrival_time", ""),
                                "duration": f"{flight.get('duration', 0) // 3600}h{(flight.get('duration', 0) % 3600) // 60}m",
                                "cost": flight.get("price", {}).get("units", 0) if isinstance(flight.get("price"), dict) else flight.get("price", 0),
                                "booking_link": self._generate_flight_deep_link(request.origin, request.destination, request.start_date, request.travelers, flight)
                            }
                            itinerary["transportation"]["optimal"].append(flight_obj)
                    
                    logger.info(f"Replaced flights with {len(fastest_flights)} fastest, {len(cheapest_flights)} cheapest, {len(optimal_flights)} optimal flights")
                else:
                    logger.warning("No real flight data available, keeping AI-generated flights")
        else:
            logger.warning("Flight data not successful, keeping AI-generated flights")
        
        # Enhance with real hotel data (if available)
        if hotel_data.get("success") and hotel_data.get("hotels"):
            logger.info("Enhancing with real hotel data...")
            
            # Calculate checkout date
            from datetime import datetime, timedelta
            start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
            checkout_date = start_date + timedelta(days=request.duration_days)
            checkout_date_str = checkout_date.strftime("%Y-%m-%d")
            
            # Ensure accommodation structure exists
            if "accommodation" not in itinerary:
                itinerary["accommodation"] = {}
            
            # Categorize hotels based on price
            budget_hotels = []
            moderate_hotels = []
            luxury_hotels = []
            
            for hotel in hotel_data["hotels"]:
                price = hotel.get('price_per_night', 0)
                if price <= 50:  # Budget threshold
                    budget_hotels.append(hotel)
                elif price <= 150:  # Moderate threshold
                    moderate_hotels.append(hotel)
                else:  # Luxury threshold
                    luxury_hotels.append(hotel)
            
            # Replace AI-generated hotels with real API data
            itinerary["accommodation"] = {
                "budget": [],
                "moderate": [],
                "luxury": []
            }
            
            # Add budget hotels (up to 8)
            for hotel in budget_hotels[:8]:
                hotel_obj = {
                    "name": hotel.get('name', 'Hotel'),
                    "location": hotel.get('location', 'Unknown'),
                    "price_per_night": self._format_hotel_price(hotel.get('price_per_night', 0)),
                    "rating": hotel.get('rating', 'N/A'),
                    "amenities": hotel.get('amenities', []),
                    "booking_link": self._generate_hotel_deep_link(hotel, request.destination, request.start_date, checkout_date_str, request.travelers)
                }
                itinerary["accommodation"]["budget"].append(hotel_obj)
            
            # Add moderate hotels (up to 8)
            for hotel in moderate_hotels[:8]:
                hotel_obj = {
                    "name": hotel.get('name', 'Hotel'),
                    "location": hotel.get('location', 'Unknown'),
                    "price_per_night": self._format_hotel_price(hotel.get('price_per_night', 0)),
                    "rating": hotel.get('rating', 'N/A'),
                    "amenities": hotel.get('amenities', []),
                    "booking_link": self._generate_hotel_deep_link(hotel, request.destination, request.start_date, checkout_date_str, request.travelers)
                }
                itinerary["accommodation"]["moderate"].append(hotel_obj)
            
            # Add luxury hotels (up to 8)
            for hotel in luxury_hotels[:8]:
                hotel_obj = {
                    "name": hotel.get('name', 'Hotel'),
                    "location": hotel.get('location', 'Unknown'),
                    "price_per_night": self._format_hotel_price(hotel.get('price_per_night', 0)),
                    "rating": hotel.get('rating', 'N/A'),
                    "amenities": hotel.get('amenities', []),
                    "booking_link": self._generate_hotel_deep_link(hotel, request.destination, request.start_date, checkout_date_str, request.travelers)
                }
                itinerary["accommodation"]["luxury"].append(hotel_obj)
            
            logger.info(f"Replaced hotels with {len(budget_hotels[:8])} budget, {len(moderate_hotels[:8])} moderate, {len(luxury_hotels[:8])} luxury hotels")
        else:
            logger.warning("Hotel data not successful, keeping AI-generated hotels")
        
        return itinerary
    
    def _format_hotel_price(self, price: Any) -> str:
        """Format hotel price to be user-friendly and consistent"""
        try:
            if price is None:
                return "$0"
            
            # Convert to float if it's a string or other type
            if isinstance(price, str):
                price = float(price)
            elif isinstance(price, (int, float)):
                price = float(price)
            else:
                return "$0"
            
            # Round to 2 decimal places for currency display
            price = round(price, 2)
            
            # Format as currency
            return f"${price:.2f}"
            
        except (ValueError, TypeError):
            return "$0"
    
    def _generate_hotel_deep_link(self, hotel: Dict[str, Any], destination: str, checkin_date: str, checkout_date: str, travelers: int) -> str:
        """Generate a proper deep link for specific hotel booking using Google Hotels
        
        Note: Prices shown in our system may differ from Google Hotels due to:
        - Real-time pricing and availability
        - Special deals and discounts
        - Different currency conversions
        - Taxes and fees inclusion
        """
        try:
            # Google Hotels uses a complex parameter system that's difficult to replicate
            # Let's use a simpler, more reliable approach that will work consistently
            
            # Use the destination from the request instead of hotel location
            if not destination or destination.strip() == "":
                destination = "Unknown"
            
            # Format dates properly
            from datetime import datetime
            try:
                checkin_parsed = datetime.strptime(checkin_date, "%Y-%m-%d")
                checkout_parsed = datetime.strptime(checkout_date, "%Y-%m-%d")
                formatted_checkin = checkin_parsed.strftime("%Y-%m-%d")
                formatted_checkout = checkout_parsed.strftime("%Y-%m-%d")
            except:
                formatted_checkin = checkin_date
                formatted_checkout = checkout_date
            
            # Create a more specific Google Hotels search URL that includes the hotel name
            # This will help users find the specific hotel more easily
            from urllib.parse import quote
            destination_encoded = quote(destination)
            
            # Get hotel name for more specific search
            hotel_name = hotel.get("name", "").strip()
            if hotel_name and hotel_name.lower() != "hotel" and hotel_name.lower() != "unknown":
                # Include hotel name in search for more specific results
                hotel_name_encoded = quote(hotel_name)
                return f"https://www.google.com/travel/hotels/search?q={hotel_name_encoded}%20in%20{destination_encoded}%20from%20{formatted_checkin}%20to%20{formatted_checkout}"
            else:
                # Fallback to general destination search if no specific hotel name
                return f"https://www.google.com/travel/hotels/search?q=Hotels%20in%20{destination_encoded}%20from%20{formatted_checkin}%20to%20{formatted_checkout}"
            
        except Exception as e:
            logger.error(f"Error generating hotel deep link: {str(e)}")
            # Fallback to basic Google Hotels search
            hotel_name = hotel.get("name", "").strip()
            if hotel_name and hotel_name.lower() != "hotel" and hotel_name.lower() != "unknown":
                return f"https://www.google.com/travel/hotels/search?q={hotel_name}%20in%20{destination}%20from%20{checkin_date}%20to%20{checkout_date}"
            else:
                return f"https://www.google.com/travel/hotels/search?q=Hotels%20in%20{destination}%20from%20{checkin_date}%20to%20{checkout_date}"
    
    def _generate_flight_deep_link(self, origin: str, destination: str, date: str, travelers: int, flight: Dict[str, Any]) -> str:
        """Generate a proper deep link for specific flight booking using Google Flights"""
        try:
            # Google Flights has changed their URL structure multiple times
            # Let's use the most reliable approach - direct search with basic parameters
            
            # Format the date properly (YYYY-MM-DD)
            from datetime import datetime
            try:
                parsed_date = datetime.strptime(date, "%Y-%m-%d")
                formatted_date = parsed_date.strftime("%Y-%m-%d")
            except:
                formatted_date = date
            
            # Create a simple, reliable Google Flights search URL
            # This will take users to Google Flights with the route pre-filled
            from urllib.parse import quote
            origin_encoded = quote(origin)
            destination_encoded = quote(destination)
            
            # Use the most reliable Google Flights URL structure
            # This format should work consistently
            return f"https://www.google.com/travel/flights/search?q=Flights%20from%20{origin_encoded}%20to%20{destination_encoded}%20on%20{formatted_date}"
                
        except Exception as e:
            logger.error(f"Error generating flight deep link: {str(e)}")
            # Fallback to the most basic Google Flights search
            from urllib.parse import quote
            return f"https://www.google.com/travel/flights/search?q=Flights%20from%20{quote(origin)}%20to%20{quote(destination)}%20on%20{date}" 