import os
import json
import logging
import re
import calendar
import time
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import anthropic
from dotenv import load_dotenv

from .trip_planner_interface import (
    TripPlannerProvider, 
    TripPlanRequest, 
    TripPlanResponse, 
    TripPlanMetadata,
    ProviderType, 
    TripPlanQuality
)
from .hotel_client import HotelClient
from .search_one_way import search_one_way_flights
from .models import HotelSearchRequest
from services.budget_allocation_service import BudgetAllocationService
from services.price_display_service import price_display_service
from services.location_detection_service import LocationDetectionService
from services.maps_weather_service import MapsWeatherService

load_dotenv()

logger = logging.getLogger(__name__)

class EnhancedAITripProvider(TripPlannerProvider):
    """Enhanced AI-powered trip planning provider using Claude with real API integration"""
    
    def __init__(self):
        self.client = anthropic.Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))
        self._available = bool(os.getenv("ANTHROPIC_API_KEY"))
        self.hotel_client = HotelClient()
        self.budget_service = BudgetAllocationService()
        self.location_service = LocationDetectionService()
        self.maps_weather_service = MapsWeatherService()
    
    def get_provider_type(self) -> ProviderType:
        return ProviderType.AI
    
    def get_quality_estimate(self) -> TripPlanQuality:
        return TripPlanQuality.EXCELLENT
    
    def is_available(self) -> bool:
        return self._available
    
    async def plan_trip(self, request: TripPlanRequest) -> TripPlanResponse:
        """Generate a comprehensive trip plan using AI with real API integration"""
        try:
            logger.info(f"[DEBUG] plan_trip called with request: {request.dict()}")
            # Calculate budget allocation (30-35% for hotels)
            budget_allocation = self._calculate_budget_allocation(request)
            # Get real hotel data with budget constraints
            hotel_data = await self._get_hotel_recommendations(request, budget_allocation)
            # Get real flight data
            flight_data = await self._get_flight_recommendations(request)
            # Get weather data for destination
            weather_data = await self._get_weather_data(request)
            # Create enhanced AI prompt with real data and budget allocation
            prompt = self._create_enhanced_planning_prompt(request, hotel_data, flight_data, budget_allocation, weather_data)
            logger.info(f"[DEBUG] Claude prompt being sent:\n{prompt}")
            # Call Claude
            response = await self._call_claude(prompt)
            logger.info(f"[DEFENSIVE] Full raw Claude response before parsing (plan_trip):\n{response}")
            
            # Check if response indicates an error or overload
            if self._is_error_response(response):
                logger.warning("AI response indicates error/overload, returning user-friendly error")
                return self._create_error_response("AI service temporarily unavailable. Please try again in 2-3 minutes.")
            
            # Parse the response
            itinerary = self._parse_ai_response(response)
            
            # Validate that AI generated real content
            content_is_valid = self._validate_ai_content(itinerary)
            if not content_is_valid:
                logger.warning("AI generated placeholder content instead of real data")
            
            itinerary, is_incomplete = self._normalize_ai_response(itinerary)
            logger.info(f"[DEFENSIVE] Output of _parse_ai_response before normalization: {itinerary}")
            logger.info(f"[DEFENSIVE] Is incomplete response: {is_incomplete}")
            # Enhance with real booking links
            itinerary = self._enhance_with_real_booking_links(itinerary, hotel_data, flight_data, request, original_ai_response=itinerary.copy())
            # Create metadata
            metadata = TripPlanMetadata(
                provider=ProviderType.AI,
                quality=TripPlanQuality.EXCELLENT,
                confidence_score=0.95,
                data_freshness="real_time",
                last_updated=datetime.now().isoformat(),
                source_notes=[
                    "Generated by Claude AI with real API integration",
                    "Includes real hotel availability and pricing",
                    "Flight recommendations based on actual search results",
                    "Booking links are personalized and functional"
                ]
            )
            # Add budget allocation to estimated costs
            estimated_costs = itinerary.get("estimated_costs", {})
            if budget_allocation:
                estimated_costs.update(budget_allocation.get("budget_breakdown", {}))
            logger.info(f"[DEBUG] plan_trip returning success with itinerary and estimated_costs.")
            logger.info(f"[DEFENSIVE] Raw AI itinerary before merging: {itinerary}")
            itinerary_merged = self._enhance_with_real_booking_links(itinerary, hotel_data, flight_data, request, weather_data, original_ai_response=itinerary.copy())
            logger.info(f"[DEFENSIVE] Merged itinerary to be returned: {itinerary_merged}")
            # Check if we have any useful data (flights, hotels, or other content)
            has_flights = bool(itinerary_merged.get('outbound') or itinerary_merged.get('return') or itinerary_merged.get('transportation'))
            has_hotels = bool(itinerary_merged.get('hotels') or itinerary_merged.get('accommodation'))
            has_other_content = bool(itinerary_merged.get('trip_summary') or itinerary_merged.get('itinerary') or itinerary_merged.get('practical_info'))
            
            if not (has_flights or has_hotels or has_other_content):
                logger.error("[DEFENSIVE] No useful data found in AI response, returning fallback.")
                return TripPlanResponse(
                    success=False,
                    itinerary={
                        "trip_summary": {
                            "title": "Trip Planning",
                            "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
                            "highlights": ["Please retry", "Contact support if issue persists"]
                        },
                        "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                        "accommodation": {"moderate": []},
                        "itinerary": {},
                        "estimated_costs": {"total": "$0"},
                        "practical_info": {"currency": "USD", "language": "English"},
                        "notes": "Some data could not be found (e.g., no direct airport for this destination, used nearest major airport and included ground transfer if possible)."
                    },
                    metadata=TripPlanMetadata(
                        provider=ProviderType.AI,
                        quality=TripPlanQuality.BASIC,
                        confidence_score=0.0,
                        data_freshness="unknown",
                        last_updated=datetime.now().isoformat(),
                        source_notes=["Fallback response due to API error"],
                        fallback_used=True
                    ),
                    error_message="AI planning service temporarily unavailable: no useful data generated"
                )
            # Otherwise, return the merged itinerary
            # Determine quality based on what data we have
            if has_flights and has_hotels and has_other_content:
                quality = TripPlanQuality.EXCELLENT
                confidence_score = 0.95
                source_notes = [
                    "Generated by Claude AI with real API integration",
                    "Includes real hotel availability and pricing",
                    "Flight recommendations based on actual search results",
                    "Booking links are personalized and functional"
                ]
            elif has_flights or has_hotels:
                quality = TripPlanQuality.GOOD
                confidence_score = 0.7
                source_notes = [
                    "Generated by Claude AI with partial data",
                    "Some fields may be missing or incomplete",
                    "Flight/hotel data available"
                ]
            else:
                quality = TripPlanQuality.BASIC
                confidence_score = 0.5
                source_notes = [
                    "Generated by Claude AI with limited data",
                    "Some fields may be missing"
                ]
            
            # Set success based on whether response is incomplete
            # But also check if we have meaningful content even if structure is incomplete
            has_meaningful_content = (
                itinerary_merged.get('trip_summary', {}).get('title', '') not in ['Trip Planning Incomplete', 'Trip Planning Error'] or
                len(itinerary_merged.get('itinerary', {})) > 0 or
                len(itinerary_merged.get('transportation', {}).get('fastest', [])) > 0 or
                len(itinerary_merged.get('accommodation', {}).get('moderate', [])) > 0
            )
            
            success = not is_incomplete or has_meaningful_content
            
            return TripPlanResponse(
                success=success,
                itinerary=itinerary_merged,
                estimated_costs=itinerary_merged.get("estimated_costs", {}),
                metadata=TripPlanMetadata(
                    provider=ProviderType.AI,
                    quality=quality,
                    confidence_score=confidence_score,
                    data_freshness="real_time",
                    last_updated=datetime.now().isoformat(),
                    source_notes=source_notes,
                    fallback_used=is_incomplete  # Mark as fallback if incomplete
                )
            )
        except Exception as e:
            logger.error(f"[DEBUG] Enhanced AI trip planning failed: {str(e)}")
            # Return a fallback response with a notes field
            return TripPlanResponse(
                success=False,
                itinerary={
                    "trip_summary": {
                        "title": "Trip Planning",
                        "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
                        "highlights": ["Please retry", "Contact support if issue persists"]
                    },
                    "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                    "accommodation": {"moderate": []},
                    "itinerary": {},
                    "estimated_costs": {"total": "$0"},
                    "practical_info": {"currency": "USD", "language": "English"},
                    "notes": "Some data could not be found (e.g., no direct airport for this destination, used nearest major airport and included ground transfer if possible)."
                },
                metadata=TripPlanMetadata(
                    provider=ProviderType.AI,
                    quality=TripPlanQuality.BASIC,
                    confidence_score=0.0,
                    data_freshness="unknown",
                    last_updated=datetime.now().isoformat(),
                    source_notes=["Fallback response due to API error"],
                    fallback_used=True
                ),
                error_message=f"AI planning service temporarily unavailable: {str(e)}"
            )
    
    async def _get_hotel_recommendations(self, request: TripPlanRequest, budget_allocation: Dict[str, Any] = None) -> Dict[str, Any]:
        """Get real hotel recommendations using the hotel API with budget allocation"""
        try:
            # Require start_date to be provided
            if not request.start_date:
                logger.error("Start date is required for hotel search")
                return {"success": False, "hotels": [], "error": "Start date is required"}
            
            # Calculate check-in and check-out dates
            # Handle month-year format (e.g., "august 2025")
            if re.match(r'^[a-zA-Z]+\s+\d{4}$', request.start_date):
                # Convert "august 2025" to "2025-08-01"
                month_names = {name.lower(): i for i, name in enumerate(calendar.month_name) if name}
                parts = request.start_date.lower().split()
                if len(parts) == 2 and parts[0] in month_names:
                    month = month_names[parts[0]]
                    year = int(parts[1])
                    request.start_date = f"{year}-{month:02d}-01"
            
            start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
            end_date = start_date + timedelta(days=request.duration_days)
            
            # Create hotel search request
            hotel_request = HotelSearchRequest(
                location=request.destination,
                check_in=request.start_date,
                check_out=end_date.strftime("%Y-%m-%d"),
                adults=request.travelers,
                children=[],
                rooms=1,
                currency="USD"
            )
            
            # Use budget allocation for hotel search if available
            max_budget = None
            if budget_allocation and budget_allocation.get("hotel_budget_allocation"):
                hotel_budget = budget_allocation["hotel_budget_allocation"]
                per_night = float(hotel_budget["per_night"].replace("$", ""))
                max_budget = per_night * 1.2  # Allow 20% flexibility
            else:
                max_budget = self._get_budget_amount(request.budget_range)
            
            # Search for hotels
            hotel_response = self.hotel_client.smart_hotel_search(
                hotel_request, 
                max_budget=max_budget
            )
            
            if hotel_response.hotels and len(hotel_response.hotels) > 0:
                # Return top 8 hotels (minimum as requested)
                top_hotels = hotel_response.hotels[:8]
                
                # Detect user's currency and determine trip currency strategy
                user_location = await self.location_service.detect_user_location_with_consent()
                user_country = user_location.get("country_code", "US")
                user_currency = user_location.get("currency", "USD")
                
                # Determine origin and destination countries
                origin_country = await self.location_service.get_country_from_city(request.origin)
                destination_country = await self.location_service.get_country_from_city(request.destination)
                
                # Get currency strategy for this trip
                currency_strategy = self.location_service.determine_trip_currency_strategy(
                    origin_country, destination_country, user_country
                )
                
                primary_currency = currency_strategy["primary_currency"]
                secondary_currency = currency_strategy["secondary_currency"]
                
                logger.info(f"Trip currency strategy: {currency_strategy}")
                
                hotels_with_prices = []
                for hotel in top_hotels:
                    if hotel.hotel and hotel.hotel.name:  # Check if hotel exists and has a name
                        hotels_with_prices.append({
                            "name": hotel.hotel.name,
                            "rating": hotel.hotel.rating,
                            "price_per_night": hotel.average_price_per_night,
                            "location": f"{hotel.hotel.city}, {hotel.hotel.country}",
                            "amenities": hotel.hotel.amenities or [],
                            "booking_link": self.hotel_client.generate_hotel_booking_url(
                                hotel.hotel.hotel_id,
                                request.start_date,
                                end_date.strftime("%Y-%m-%d"),
                                request.travelers,
                                [],
                                1,
                                "USD"
                            ),
                            "hotel_id": hotel.hotel.hotel_id
                        })
                
                # Convert prices to primary currency
                converted_hotels = await price_display_service.convert_hotel_prices(hotels_with_prices, primary_currency)
                
                return {
                    "success": True,
                    "hotels": converted_hotels,
                    "currency_strategy": currency_strategy,
                    "trip_info": {
                        "origin_country": origin_country,
                        "destination_country": destination_country,
                        "user_country": user_country,
                        "primary_currency": primary_currency,
                        "secondary_currency": secondary_currency
                    }
                }
            else:
                return {"success": False, "hotels": []}
                
        except Exception as e:
            logger.error(f"Hotel search failed: {str(e)}")
            return {"success": False, "hotels": []}
    
    async def _get_weather_data(self, request: TripPlanRequest) -> Dict[str, Any]:
        """Get weather data for the destination"""
        try:
            # Get destination coordinates
            coords = await self.maps_weather_service.get_destination_coordinates(request.destination)
            if not coords:
                logger.warning(f"Could not get coordinates for {request.destination}")
                return {}
            
            # Get weather forecast for the trip duration
            weather = await self.maps_weather_service.get_weather_forecast(
                coords["lat"], 
                coords["lng"], 
                days=request.duration_days
            )
            
            if weather:
                logger.info(f"Weather data retrieved for {request.destination}")
                return {
                    "destination": request.destination,
                    "coordinates": coords,
                    "weather_forecast": weather
                }
            else:
                logger.warning(f"No weather data available for {request.destination}")
                return {}
                
        except Exception as e:
            logger.error(f"Error getting weather data: {e}")
            return {}

    async def _get_flight_recommendations(self, request: TripPlanRequest) -> Dict[str, Any]:
        """Get real flight recommendations using the flight API"""
        try:
            # Require start_date to be provided
            if not request.start_date:
                logger.error("Start date is required for flight search")
                return {"success": False, "flights": [], "error": "Start date is required"}
            
            # Calculate return date (for round trip)
            # Handle month-year format (e.g., "august 2025")
            if re.match(r'^[a-zA-Z]+\s+\d{4}$', request.start_date):
                # Convert "august 2025" to "2025-08-01"
                month_names = {name.lower(): i for i, name in enumerate(calendar.month_name) if name}
                parts = request.start_date.lower().split()
                if len(parts) == 2 and parts[0] in month_names:
                    month = month_names[parts[0]]
                    year = int(parts[1])
                    request.start_date = f"{year}-{month:02d}-01"
            
            start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
            return_date = start_date + timedelta(days=request.duration_days)
            
            # Use aiohttp to call the flight API directly
            import aiohttp
            import json
            
            # Prepare search parameters
            search_params = {
                "origin": request.origin,
                "destination": request.destination,
                "date": request.start_date,
                "return_date": return_date.strftime("%Y-%m-%d")
            }
            
            logger.info(f"Calling flight API with params: {search_params}")
            
            # Make request to the flight search endpoint
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    "http://localhost:8000/api/search",
                    json=search_params
                ) as response:
                    logger.info(f"Flight API response status: {response.status}")
                    
                    if response.status == 200:
                        result = await response.json()
                        logger.info(f"Flight API response: {result}")
                        
                        if result.get("success") and result.get("flights"):
                            logger.info(f"Found {len(result['flights'])} flights")
                            
                            # Detect user's currency and determine trip currency strategy
                            user_location = await self.location_service.detect_user_location_with_consent()
                            user_country = user_location.get("country_code", "US")
                            user_currency = user_location.get("currency", "USD")
                            
                            # Determine origin and destination countries
                            origin_country = await self.location_service.get_country_from_city(request.origin)
                            destination_country = await self.location_service.get_country_from_city(request.destination)
                            
                            # Get currency strategy for this trip
                            currency_strategy = self.location_service.determine_trip_currency_strategy(
                                origin_country, destination_country, user_country
                            )
                            
                            primary_currency = currency_strategy["primary_currency"]
                            secondary_currency = currency_strategy["secondary_currency"]
                            
                            logger.info(f"Flight trip currency strategy: {currency_strategy}")
                            
                            # Convert flight prices to primary currency
                            converted_flights = await price_display_service.convert_flight_prices(result["flights"], primary_currency)
                            
                            return {
                                "success": True,
                                "flights": converted_flights,
                                "categorized_flights": result.get("categorized_flights", {})
                            }
                        else:
                            logger.error(f"No flights found in response: {result}")
                            return {"success": False, "flights": []}
                    else:
                        error_text = await response.text()
                        logger.error(f"Flight API error: {error_text}")
                        return {"success": False, "flights": []}
                
        except Exception as e:
            logger.error(f"Flight search failed: {str(e)}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")
            return {"success": False, "flights": []}
    
    def _get_budget_amount(self, budget_range: str) -> Optional[float]:
        """Convert budget range to dollar amount"""
        if not budget_range:
            return 300  # Default moderate budget
            
        budget_range_lower = budget_range.lower()
        
        # Check for exact matches first
        budget_map = {
            "budget": 100,
            "moderate": 300,
            "luxury": 500
        }
        
        if budget_range_lower in budget_map:
            return budget_map[budget_range_lower]
        
        # Check for patterns like "Budget ($1000)" or "Luxury ($300+/day)"
        import re
        
        # Extract dollar amount from patterns like "($1000)" or "($300+)"
        dollar_pattern = r'\$(\d+(?:\+)?)'
        match = re.search(dollar_pattern, budget_range)
        if match:
            amount_str = match.group(1)
            if amount_str.endswith('+'):
                # For ranges like "$300+", use the base amount
                return float(amount_str[:-1])
            else:
                return float(amount_str)
        
        # Check for keywords in the string
        if "budget" in budget_range_lower:
            return 100
        elif "luxury" in budget_range_lower:
            return 500
        elif "moderate" in budget_range_lower:
            return 300
        
        # Default fallback
        return 300
    
    def _calculate_budget_allocation(self, request: TripPlanRequest) -> Dict[str, Any]:
        """Calculate budget allocation with 30-35% for hotels"""
        try:
            # Get total budget
            total_budget = getattr(request, 'total_budget', None) or self._get_budget_amount(request.budget_range)
            if not total_budget:
                total_budget = 300  # Default moderate budget
            
            # Calculate duration - handle None dates
            if not request.start_date or not request.end_date:
                # Use duration_days if available, otherwise default to 3 days
                duration = request.duration_days or 3
            else:
                start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
                end_date = datetime.strptime(request.end_date, "%Y-%m-%d")
                duration = (end_date - start_date).days
            
            # Calculate budget allocation
            allocation = self.budget_service.calculate_budget_allocation(
                total_budget=total_budget,
                trip_duration=duration,
                travelers=request.travelers
            )
            
            return allocation
            
        except Exception as e:
            logger.error(f"Error calculating budget allocation: {e}")
            return None
    
    def _create_enhanced_planning_prompt(self, request: TripPlanRequest,
                                         hotel_data: Dict[str, Any],
                                         flight_data: Dict[str, Any],
                                         budget_allocation: Dict[str, Any] = None,
                                         weather_data: Dict[str, Any] = None) -> str:
        """Create a production-ready trip planning prompt with optimal token usage"""

        interests_text = ", ".join(request.interests) if request.interests else "general exploration"
        total_budget = getattr(request, 'total_budget', None)
        budget_per_person = int(total_budget / request.travelers) if total_budget else 0

        # Calculate end date
        from datetime import datetime, timedelta
        start_date = datetime.strptime(request.start_date, "%Y-%m-%d")
        end_date = start_date + timedelta(days=request.duration_days - 1)
        end_date_str = end_date.strftime("%Y-%m-%d")

        prompt = f"""Create a trip plan from {request.origin} to {request.destination} for {request.duration_days} days.

You MUST return this EXACT JSON structure with real content:

{{
  "trip_summary": {{
    "title": "Real title for {request.destination}",
    "overview": "Real overview for {request.destination}",
    "highlights": ["Real highlight 1", "Real highlight 2", "Real highlight 3"],
    "weather_summary": {{
      "avg_temp_f": 75,
      "avg_temp_c": 24,
      "conditions": "Mostly sunny with occasional rain",
      "packing_tip": "Pack light layers and rain gear"
    }}
  }},
  "outbound": [
    {{"category": "budget", "airline": "Real airline", "price": 500, "departure": "10:00", "arrival": "18:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "budget", "airline": "Real airline", "price": 550, "departure": "14:00", "arrival": "22:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "budget", "airline": "Real airline", "price": 600, "departure": "16:00", "arrival": "00:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "standard", "airline": "Real airline", "price": 700, "departure": "09:00", "arrival": "17:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "standard", "airline": "Real airline", "price": 750, "departure": "11:00", "arrival": "19:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "standard", "airline": "Real airline", "price": 800, "departure": "13:00", "arrival": "21:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "premium", "airline": "Real airline", "price": 1000, "departure": "08:00", "arrival": "16:00", "duration": "8h 0m", "stops": 0, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "premium", "airline": "Real airline", "price": 1100, "departure": "12:00", "arrival": "20:00", "duration": "8h 0m", "stops": 0, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}},
    {{"category": "premium", "airline": "Real airline", "price": 1200, "departure": "15:00", "arrival": "23:00", "duration": "8h 0m", "stops": 0, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.origin}%20to%20{request.destination}%20on%20{request.start_date}"}}
  ],
  "return": [
    {{"category": "budget", "airline": "Real airline", "price": 500, "departure": "10:00", "arrival": "18:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "budget", "airline": "Real airline", "price": 550, "departure": "14:00", "arrival": "22:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "budget", "airline": "Real airline", "price": 600, "departure": "16:00", "arrival": "00:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "standard", "airline": "Real airline", "price": 700, "departure": "09:00", "arrival": "17:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "standard", "airline": "Real airline", "price": 750, "departure": "11:00", "arrival": "19:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "standard", "airline": "Real airline", "price": 800, "departure": "13:00", "arrival": "21:00", "duration": "8h 0m", "stops": 1, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "premium", "airline": "Real airline", "price": 1000, "departure": "08:00", "arrival": "16:00", "duration": "8h 0m", "stops": 0, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "premium", "airline": "Real airline", "price": 1100, "departure": "12:00", "arrival": "20:00", "duration": "8h 0m", "stops": 0, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}},
    {{"category": "premium", "airline": "Real airline", "price": 1200, "departure": "15:00", "arrival": "23:00", "duration": "8h 0m", "stops": 0, "booking_link": "https://www.google.com/travel/flights/search?q=Flights%20from%20{request.destination}%20to%20{request.origin}%20on%20{end_date_str}"}}
  ],
  "hotels": [
    {{"category": "budget", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 100, "total_cost": 500, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "budget", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 110, "total_cost": 550, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "budget", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 120, "total_cost": 600, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "moderate", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 200, "total_cost": 1000, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "moderate", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 220, "total_cost": 1100, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "moderate", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 240, "total_cost": 1200, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "luxury", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 400, "total_cost": 2000, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "luxury", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 450, "total_cost": 2250, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}},
    {{"category": "luxury", "name": "Real hotel name", "area": "Real neighborhood", "price_per_night": 500, "total_cost": 2500, "booking_link": "https://www.google.com/travel/hotels/search?q=Hotel%20Name%20in%20{request.destination}%20from%20{request.start_date}%20to%20{end_date_str}"}}
  ],
  "itinerary": {{
    "day_1": {{
      "theme": "Real theme for {request.destination}",
      "weather": {{
        "temperature_f": 75,
        "temperature_c": 24,
        "condition": "sunny",
        "rain_chance": 10,
        "wind_speed": 5
      }},
      "morning": {{"activity": "Real activity", "location": "Real location", "cost": 0}},
      "afternoon": {{"activity": "Real activity", "location": "Real location", "cost": 0}},
      "evening": {{"activity": "Real activity", "location": "Real location", "cost": 50}}
    }}
  }},
  "practical_info": {{
    "currency": "Real currency for {request.destination}",
    "language": "Real language for {request.destination}",
    "emergency_numbers": ["Real emergency number"],
    "packing_suggestions": ["Real packing item"]
  }},
  "cultural_insights": {{
    "local_customs": ["Real custom for {request.destination}"],
    "etiquette": ["Real etiquette for {request.destination}"],
    "dress_code": "Real dress code for {request.destination}"
  }},
  "insider_tips": [
    "Real insider tip for {request.destination}",
    "Real insider tip for {request.destination}",
    "Real insider tip for {request.destination}"
  ]
}}

Replace all "Real" placeholders with actual content for {request.destination}. 

IMPORTANT WEATHER REQUIREMENTS:
- Include daily weather for each day with temperature in both Fahrenheit and Celsius
- Specify weather conditions (sunny, rainy, cloudy, stormy, etc.)
- Include rain/snow/storm timing if applicable
- Add weather-based activity recommendations
- Include weather summary in trip_summary with average temperatures and conditions

Return ONLY this JSON structure."""

        return prompt
    
    async def _call_claude(self, prompt: str) -> str:
        """Call Claude API with the planning prompt"""
        
        try:
            response = self.client.messages.create(
                model="claude-opus-4-1-20250805",
                max_tokens=8000,
                temperature=0.7,
                messages=[
                    {
                        "role": "user",
                        "content": prompt
                    }
                ]
            )
            
            return response.content[0].text
            
        except Exception as e:
            logger.error(f"Claude API call failed: {str(e)}")
            # Check if it's an overload error (529)
            if "529" in str(e) or "overloaded" in str(e).lower():
                logger.warning("Claude API is overloaded, returning user-friendly error response")
                return self._generate_overload_response()
            else:
                logger.error(f"Claude API error: {str(e)}")
                return self._generate_fallback_response()
    
    def _generate_overload_response(self) -> str:
        """Generate a user-friendly response when Claude API is overloaded"""
        return """```json
{
  "trip_summary": {
    "title": "AI Service Temporarily Unavailable",
    "overview": "Our AI planning service is currently experiencing high demand. Please try again in a few minutes.",
    "highlights": ["Service will be back shortly", "Try again in 2-3 minutes"],
    "best_time_to_visit": "TBD",
    "weather_info": "TBD",
    "start_date": "TBD",
    "end_date": "TBD"
  },
  "transportation": {
    "fastest": [],
    "cheapest": [],
    "optimal": []
  },
  "accommodation": {
    "moderate": []
  },
  "itinerary": {},
  "estimated_costs": {
    "accommodation": "$0",
    "transportation": "$0",
    "meals": "$0",
    "activities": "$0",
    "total": "$0"
  },
  "practical_info": {
    "currency": "USD",
    "language": "English",
    "timezone": "TBD",
    "emergency_numbers": ["911"],
    "cultural_tips": ["Please try again in a few minutes"],
    "packing_suggestions": ["TBD"]
  },
  "notes": "AI service temporarily overloaded. Please retry in 2-3 minutes."
}
```"""

    def _is_error_response(self, response: str) -> bool:
        """Check if the AI response indicates an error or overload"""
        error_indicators = [
            "temporary issues",
            "experiencing high demand", 
            "temporarily unavailable",
            "please try again",
            "service will be back",
            "overloaded",
            "TBD",
            "trip planning incomplete",
            "incomplete ai response",
            "please retry"
        ]
        
        response_lower = response.lower()
        return any(indicator in response_lower for indicator in error_indicators)
    
    def _create_error_response(self, message: str) -> TripPlanResponse:
        """Create a user-friendly error response"""
        return TripPlanResponse(
            success=False,
            itinerary={
                "trip_summary": {
                    "title": "AI Service Temporarily Unavailable",
                    "overview": message,
                    "highlights": ["Please try again in 2-3 minutes", "Service will be back shortly"]
                },
                "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                "accommodation": {"moderate": []},
                "itinerary": {},
                "estimated_costs": {"total": "$0"},
                "practical_info": {"currency": "USD", "language": "English"},
                "notes": "AI service temporarily overloaded. Please retry in 2-3 minutes."
            },
            metadata=TripPlanMetadata(
                provider=ProviderType.AI,
                quality=TripPlanQuality.BASIC,
                confidence_score=0.0,
                data_freshness="unknown",
                last_updated=datetime.now().isoformat(),
                source_notes=["AI service temporarily overloaded"],
                fallback_used=True
            ),
            error_message=message
        )

    def _generate_fallback_response(self) -> str:
        """Generate a fallback response when Claude API is unavailable"""
        return """```json
{
  "trip_summary": {
    "title": "Trip Planning",
    "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
    "highlights": ["Please retry", "Contact support if issue persists"],
    "best_time_to_visit": "TBD",
    "weather_info": "TBD",
    "start_date": "TBD",
    "end_date": "TBD"
  },
  "transportation": {
    "fastest": [],
    "cheapest": [],
    "optimal": []
  },
  "accommodation": {
    "moderate": []
  },
  "itinerary": {},
  "estimated_costs": {
    "accommodation": "$0",
    "transportation": "$0",
    "meals": "$0",
    "activities": "$0",
    "total": "$0"
  },
  "practical_info": {
    "currency": "USD",
    "language": "English",
    "timezone": "TBD",
    "emergency_numbers": ["911"],
    "cultural_tips": ["Please retry"],
    "packing_suggestions": ["TBD"]
  }
}
```"""
    
    def _extract_largest_valid_json(self, text: str) -> dict:
        """Extract the largest valid JSON object from text, trying progressively smaller chunks"""
        import json
        import logging
        logger = logging.getLogger("api.enhanced_ai_provider")
        
        # Try to find the largest valid JSON by progressively removing content from the end
        for i in range(len(text), 0, -100):  # Try every 100 characters
            try:
                chunk = text[:i]
                # Find the last complete closing brace
                brace_count = 0
                last_brace_pos = -1
                for j, char in enumerate(chunk):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            last_brace_pos = j
                
                if last_brace_pos > 0:
                    valid_chunk = chunk[:last_brace_pos + 1]
                    parsed = json.loads(valid_chunk)
                    logger.info(f"[DEFENSIVE] Found valid JSON at position {last_brace_pos}")
                    return parsed
            except:
                continue
        
        # If nothing works, return a minimal fallback
        logger.warning("[DEFENSIVE] Could not extract any valid JSON, returning fallback")
        return {
            "trip_summary": {
                "title": "JSON Parsing Error",
                "overview": "Unable to parse the AI response. Please try again.",
                "highlights": ["Please retry the request"]
            }
        }

    def _extract_largest_json_object(self, text: str) -> str:
        """Extract the largest (outermost) JSON object from a string, robust to whitespace and extra text."""
        import logging
        logger = logging.getLogger("api.enhanced_ai_provider")
        
        # First, try to find JSON with improved regex pattern
        import re
        
        # Remove markdown code blocks if present
        text = re.sub(r'```json\s*', '', text)
        text = re.sub(r'```\s*$', '', text)
        text = re.sub(r'```\s*', '', text)  # Remove any remaining ```
        
        # Try to find the complete JSON object
        # Look for the outermost JSON object by counting braces
        start = None
        brace_count = 0
        max_json = ''
        max_len = 0
        
        for i, char in enumerate(text):
            if char == '{':
                if start is None:
                    start = i
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0 and start is not None:
                    json_str = text[start:i+1]
                    if len(json_str) > max_len:
                        max_json = json_str
                        max_len = len(json_str)
                    start = None
        
        if max_json:
            logger.info(f"[DEFENSIVE] Extracted complete JSON object (len={max_len}):\n{max_json[:500]}... (truncated)")
            return max_json
        
        # Fallback to simpler regex if brace counting fails
        json_pattern = r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}'
        matches = re.findall(json_pattern, text, re.DOTALL)
        
        if matches:
            # Find the longest match
            longest_match = max(matches, key=len)
            logger.info(f"[DEFENSIVE] Found JSON with fallback regex (len={len(longest_match)}):\n{longest_match[:500]}... (truncated)")
            return longest_match
        
        logger.error("[DEFENSIVE] No JSON object found in response for extraction.")
        # Log a sample of the text to help debug
        logger.error(f"[DEFENSIVE] Text sample (first 1000 chars): {text[:1000]}")
        
        return ""

    def _parse_ai_response(self, response: str) -> dict:
        import logging
        logger = logging.getLogger("api.enhanced_ai_provider")
        logger.info(f"[DEFENSIVE] Full raw Claude response before parsing (_parse_ai_response):\n{response}")
        try:
            import json
            response = response.strip()
            
            # Always try direct JSON parse first
            try:
                logger.info("[DEFENSIVE] Attempting to parse response as JSON directly.")
                return json.loads(response)
            except Exception as e:
                logger.warning(f"[DEFENSIVE] Failed to parse response as JSON: {e}")
                logger.warning(f"[DEFENSIVE] Response that failed to parse (first 500 chars): {response[:500]}...")
                
                # Try permissive parser if available
                try:
                    import rapidjson
                    logger.info("[DEFENSIVE] Attempting to parse response with rapidjson (permissive mode).")
                    return rapidjson.loads(response, number_mode=rapidjson.NM_NATIVE, datetime_mode=rapidjson.DM_ISO8601)
                except ImportError:
                    logger.error("[DEFENSIVE] rapidjson not installed. Install python-rapidjson for permissive parsing.")
                except Exception as e2:
                    logger.warning(f"[DEFENSIVE] rapidjson also failed: {e2}")
                
                # Try to clean the response and parse again
                try:
                    # Remove any text before the first {
                    start_idx = response.find('{')
                    if start_idx != -1:
                        cleaned_response = response[start_idx:]
                        logger.info("[DEFENSIVE] Attempting to parse cleaned response (removed text before first {).")
                        
                        # Try to fix unterminated strings by finding the last complete JSON structure
                        try:
                            return json.loads(cleaned_response)
                        except json.JSONDecodeError as json_err:
                            if "Unterminated string" in str(json_err):
                                logger.warning("[DEFENSIVE] Found unterminated string, attempting to fix...")
                                # Find the last complete closing brace
                                brace_count = 0
                                last_complete_pos = -1
                                for i, char in enumerate(cleaned_response):
                                    if char == '{':
                                        brace_count += 1
                                    elif char == '}':
                                        brace_count -= 1
                                        if brace_count == 0:
                                            last_complete_pos = i
                                
                                if last_complete_pos > 0:
                                    # Truncate at the last complete JSON structure
                                    fixed_response = cleaned_response[:last_complete_pos + 1]
                                    logger.info(f"[DEFENSIVE] Truncated response at position {last_complete_pos}")
                                    try:
                                        return json.loads(fixed_response)
                                    except json.JSONDecodeError as final_err:
                                        logger.warning(f"[DEFENSIVE] Even truncated response failed to parse: {final_err}")
                                        # Try to find a smaller complete JSON structure
                                        return self._extract_largest_valid_json(fixed_response)
                            raise json_err
                except Exception as e3:
                    logger.warning(f"[DEFENSIVE] Failed to parse cleaned response: {e3}")
            
            # Use robust stack-based extraction for largest JSON object
            max_json = self._extract_largest_json_object(response)
            if max_json:
                try:
                    logger.info(f"[DEFENSIVE] Attempting to parse extracted JSON (len={len(max_json)})")
                    parsed_json = json.loads(max_json)
                    logger.info(f"[DEFENSIVE] Successfully parsed extracted JSON")
                    return parsed_json
                except Exception as e3:
                    logger.warning(f"[DEFENSIVE] Failed to parse extracted JSON: {e3}")
                    logger.warning(f"[DEFENSIVE] Extracted JSON sample: {max_json[:200]}...")
            
            logger.error("[DEFENSIVE] No JSON object found in Claude response.")
            # Return a fallback itinerary with a notes field
            return {
                "trip_summary": {
                    "title": "Trip Planning",
                    "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
                    "highlights": ["Please retry", "Contact support if issue persists"]
                },
                "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                "accommodation": {"moderate": []},
                "itinerary": {},
                "estimated_costs": {"total": "$0"},
                "practical_info": {"currency": "USD", "language": "English"},
                "notes": "Some data could not be found (e.g., no direct airport for this destination, used nearest major airport and included ground transfer if possible)."
            }
        except Exception as e:
            logger.error(f"Failed to parse AI response: {str(e)}")
            logger.error(f"Response: {response}")
            # Return a fallback itinerary with a notes field
            return {
                "trip_summary": {
                    "title": "Trip Planning",
                    "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
                    "highlights": ["Please retry", "Contact support if issue persists"]
                },
                "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                "accommodation": {"moderate": []},
                "itinerary": {},
                "estimated_costs": {"total": "$0"},
                "practical_info": {"currency": "USD", "language": "English"},
                "notes": "Some data could not be found (e.g., no direct airport for this destination, used nearest major airport and included ground transfer if possible)."
            }
    
    def _validate_ai_content(self, ai_data: dict) -> bool:
        """Validate that AI generated real content instead of copying placeholders"""
        import logging
        logger = logging.getLogger("api.enhanced_ai_provider")
        
        placeholder_indicators = [
            "Destination-specific",
            "Essential item 1",
            "Cultural tip 1", 
            "Emergency number for destination",
            "Indoor activity 1",
            "Budget dining 1",
            "Free activity 1"
        ]
        
        # Check practical_info
        practical_info = ai_data.get('practical_info', {})
        emergency_numbers = practical_info.get('emergency_numbers', [])
        packing_suggestions = practical_info.get('packing_suggestions', [])
        
        # Check cultural_insights
        cultural_insights = ai_data.get('cultural_insights', {})
        local_customs = cultural_insights.get('local_customs', [])
        
        # Check other fields
        insider_tips = ai_data.get('insider_tips', [])
        alternatives = ai_data.get('alternatives', {})
        
        all_content = []
        all_content.extend(emergency_numbers)
        all_content.extend(packing_suggestions)
        all_content.extend(local_customs)
        all_content.extend(insider_tips)
        
        # Check for placeholder content
        placeholder_found = False
        for content in all_content:
            if isinstance(content, str):
                for indicator in placeholder_indicators:
                    if indicator.lower() in content.lower():
                        logger.warning(f"[VALIDATION] Found placeholder content: {content}")
                        placeholder_found = True
        
        if placeholder_found:
            logger.warning("[VALIDATION] AI appears to have copied placeholder text instead of generating real content")
            return False
        
        logger.info("[VALIDATION] AI content appears to be real (no placeholders detected)")
        return True

    def _normalize_ai_response(self, ai_data: dict) -> tuple[dict, bool]:
        import logging
        logger = logging.getLogger("api.enhanced_ai_provider")
        
        # Defensive check: ensure ai_data is a dictionary
        if not isinstance(ai_data, dict):
            logger.error(f"[DEFENSIVE] _normalize_ai_response received non-dict: {type(ai_data)} - {ai_data}")
            # Return a fallback structure
            return {
                "trip_summary": {
                    "title": "Trip Planning Error",
                    "overview": "I'm experiencing temporary issues with my AI planning service. Please try again in a few moments.",
                    "highlights": ["Please retry", "Contact support if issue persists"]
                },
                "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                "accommodation": {"moderate": []},
                "itinerary": {},
                "estimated_costs": {"total": "$0"},
                "practical_info": {"currency": "USD", "language": "English"},
                "notes": "Data processing error occurred"
            }
        
        logger.info(f"[DEFENSIVE] _normalize_ai_response processing ai_data with keys: {list(ai_data.keys())}")
        logger.info(f"[DEFENSIVE] ai_data content: {ai_data}")
        normalized = {}
        
        # Check if we have a complete response or just a partial one
        # AI can generate different structures, so check for the most common complete structures
        has_complete_structure = (
            # Structure 1: Traditional structure
            all(key in ai_data for key in ['outbound', 'return', 'hotels', 'itinerary']) or
            # Structure 2: New structure with trip_summary
            all(key in ai_data for key in ['trip_summary', 'transportation', 'accommodation', 'itinerary']) or
            # Structure 3: Just trip_summary with detailed content
            ('trip_summary' in ai_data and 'itinerary' in ai_data and 
             isinstance(ai_data.get('itinerary'), dict) and len(ai_data['itinerary']) > 0)
        )
        if not has_complete_structure:
            logger.warning("[DEFENSIVE] Incomplete AI response detected, creating fallback structure")
            # Return a minimal valid structure for incomplete responses
            return {
                "trip_summary": ai_data.get("trip_summary", {
                    "title": "Trip Planning Incomplete",
                    "overview": "The AI response was incomplete. Please try again.",
                    "highlights": ["Please retry the request"]
                }),
                "transportation": {"fastest": [], "cheapest": [], "optimal": []},
                "accommodation": {"moderate": []},
                "itinerary": {},
                "estimated_costs": {"total": "$0"},
                "practical_info": {"currency": "USD", "language": "English"},
                "notes": "Incomplete AI response - please retry"
            }, True  # Return True to indicate this is an incomplete response

        # Process daily_itinerary first, as it's a common new format
        if 'daily_itinerary' in ai_data and isinstance(ai_data['daily_itinerary'], list):
            logger.info("[DEFENSIVE] Converting daily_itinerary array to day_X format")
            daily_itinerary = {}
            for i, day in enumerate(ai_data['daily_itinerary'], 1):
                daily_itinerary[f'day_{i}'] = day
            normalized['itinerary'] = daily_itinerary
        elif 'itinerary' in ai_data: # Fallback for old 'itinerary' or if 'daily_itinerary' was not present
            normalized['itinerary'] = ai_data['itinerary']
        elif 'detailed_itinerary' in ai_data: # Fallback for old 'detailed_itinerary'
            normalized['itinerary'] = ai_data['detailed_itinerary']

        # Process flights into transportation
        if 'flights' in ai_data and isinstance(ai_data['flights'], dict):
            logger.info("[DEFENSIVE] Converting flights to transportation format")
            flights = ai_data['flights']
            all_flights = []
            if 'outbound' in flights:
                logger.info(f"[DEFENSIVE] Processing outbound flights: {flights['outbound']}")
                all_flights.extend(flights['outbound'])
            if 'return' in flights:
                logger.info(f"[DEFENSIVE] Processing return flights: {flights['return']}")
                all_flights.extend(flights['return'])
            
            # Map flight field names to match frontend expectations
            for flight in all_flights:
                # Defensive check: ensure flight is a dictionary
                if not isinstance(flight, dict):
                    logger.warning(f"[DEFENSIVE] Skipping non-dict flight: {flight}")
                    continue
                    
                if 'departure' in flight and 'departure_time' not in flight:
                    flight['departure_time'] = flight['departure']
                if 'arrival' in flight and 'arrival_time' not in flight:
                    flight['arrival_time'] = flight['arrival']
                if 'price' in flight and 'cost' not in flight:
                    flight['cost'] = flight['price']
            
            transportation = {
                'fastest': all_flights[:3] if all_flights else [],
                'cheapest': all_flights[3:6] if len(all_flights) > 3 else [],
                'optimal': all_flights[6:9] if len(all_flights) > 6 else []
            }
            normalized['transportation'] = transportation
        elif 'outbound' in ai_data and 'return' in ai_data:
            # Handle case where flights are at top level
            logger.info("[DEFENSIVE] Converting top-level flights to transportation format")
            logger.info(f"[DEFENSIVE] outbound data: {ai_data['outbound']}")
            logger.info(f"[DEFENSIVE] return data: {ai_data['return']}")
            all_flights = []
            if 'outbound' in ai_data:
                all_flights.extend(ai_data['outbound'])
            if 'return' in ai_data:
                all_flights.extend(ai_data['return'])
            
            # Map flight field names to match frontend expectations
            for flight in all_flights:
                # Defensive check: ensure flight is a dictionary
                if not isinstance(flight, dict):
                    logger.warning(f"[DEFENSIVE] Skipping non-dict flight: {flight}")
                    continue
                    
                if 'departure' in flight and 'departure_time' not in flight:
                    flight['departure_time'] = flight['departure']
                if 'arrival' in flight and 'arrival_time' not in flight:
                    flight['arrival_time'] = flight['arrival']
                if 'price' in flight and 'cost' not in flight:
                    flight['cost'] = flight['price']
            
            transportation = {
                'fastest': all_flights[:3] if all_flights else [],
                'cheapest': all_flights[3:6] if len(all_flights) > 3 else [],
                'optimal': all_flights[6:9] if len(all_flights) > 6 else []
            }
            normalized['transportation'] = transportation
        elif 'transportation' in ai_data: # Fallback for old 'transportation' format
            normalized['transportation'] = ai_data['transportation']

        # Process hotels into accommodation
        if 'hotels' in ai_data and isinstance(ai_data['hotels'], list):
            logger.info("[DEFENSIVE] Converting hotels array to accommodation format")
            logger.info(f"[DEFENSIVE] hotels data: {ai_data['hotels']}")
            hotels = ai_data['hotels']
            
            # Map hotel field names to match frontend expectations
            for hotel in hotels:
                # Defensive check: ensure hotel is a dictionary
                if not isinstance(hotel, dict):
                    logger.warning(f"[DEFENSIVE] Skipping non-dict hotel: {hotel}")
                    continue
                    
                if 'area' in hotel and 'location' not in hotel:
                    hotel['location'] = hotel['area']
                if 'price_per_night' not in hotel and 'total_cost' in hotel:
                    # Estimate per night cost if not provided
                    hotel['price_per_night'] = hotel['total_cost']
            
            accommodation = {'budget': [], 'moderate': [], 'luxury': []}
            for hotel in hotels:
                category = hotel.get('category', 'moderate').lower()
                if category == 'budget':
                    accommodation['budget'].append(hotel)
                elif category == 'luxury':
                    accommodation['luxury'].append(hotel)
                else:
                    accommodation['moderate'].append(hotel)
            normalized['accommodation'] = accommodation
        elif 'accommodation' in ai_data: # Fallback for old 'accommodation' format
            normalized['accommodation'] = ai_data['accommodation']

        # Process budget_breakdown into estimated_costs
        if 'budget_breakdown' in ai_data:
            normalized['estimated_costs'] = ai_data['budget_breakdown']
        elif 'estimated_costs' in ai_data: # Fallback for old 'estimated_costs'
            normalized['estimated_costs'] = ai_data['estimated_costs']
        elif 'costs' in ai_data: # Fallback for old 'costs'
            normalized['estimated_costs'] = ai_data['costs']

        # Map other top-level keys
        # This key_map should NOT include keys handled by specific logic above
        key_map = {
            'overview': 'trip_summary',
            'summary': 'trip_summary',
            'trip_summary': 'trip_summary',
            'practicalInformation': 'practical_info',
            'notes': 'notes',
            'restaurants': 'restaurants', # New fields from prompt
            'key_attractions': 'key_attractions', # New fields from prompt
            'booking_priorities': 'booking_priorities', # New fields from prompt
            'insider_tips': 'insider_tips', # New fields from prompt
            'alternatives': 'alternatives', # New fields from prompt
            'cultural_insights': 'cultural_insights', # New field for practical info
        }
        
        for k, v in ai_data.items():
            if k not in ['daily_itinerary', 'itinerary', 'detailed_itinerary', 
                         'flights', 'hotels', 'transportation', 'accommodation',
                         'budget_breakdown', 'estimated_costs', 'costs']: # Exclude already handled keys
                mapped = key_map.get(k, k)
                normalized[mapped] = v

        # Ensure all required keys exist (with default empty values if not populated by AI or mapping)
        required_keys = [
            'trip_summary', 'itinerary', 'transportation', 'accommodation', 'estimated_costs', 'practical_info', 'notes',
            'restaurants', 'key_attractions', 'booking_priorities', 'insider_tips', 'alternatives', 'cultural_insights' # New fields
        ]
        for k in required_keys:
            if k not in normalized:
                if k == 'trip_summary':
                    normalized[k] = {'title': '', 'overview': '', 'highlights': []}
                elif k == 'itinerary':
                    normalized[k] = {}
                elif k == 'transportation':
                    normalized[k] = {'fastest': [], 'cheapest': [], 'optimal': []}
                elif k == 'accommodation':
                    normalized[k] = {'budget': [], 'moderate': [], 'luxury': []}
                elif k == 'estimated_costs':
                    normalized[k] = {'total': ''}
                elif k == 'practical_info':
                    normalized[k] = {'currency': '', 'language': ''}
                elif k == 'notes':
                    normalized[k] = ''
                elif k in ['restaurants', 'key_attractions', 'booking_priorities', 'insider_tips', 'cultural_insights']:
                    normalized[k] = [] if k not in ['alternatives', 'cultural_insights'] else {} # alternatives and cultural_insights are objects

        # Transform trip_summary to match frontend expectations
        if 'trip_summary' in normalized:
            summary = normalized['trip_summary']
            # Create a title from destination and duration
            if 'destination' in summary and 'duration' in summary:
                summary['title'] = f"{summary['destination']} Adventure - {summary['duration']} Days"
            
            # Create overview from destination and interests (need request object for interests)
            # For now, let's rely on AI's overview
            if 'overview' not in summary:
                summary['overview'] = ''
            
            # Create highlights from key attractions if available
            if 'key_attractions' in ai_data and not summary.get('highlights'):
                attractions = ai_data['key_attractions'][:3]  # Take first 3
                summary['highlights'] = [attr['name'] for attr in attractions]
            
            # Get start_date from itinerary if available
            if 'itinerary' in normalized and normalized['itinerary']:
                first_day = next(iter(normalized['itinerary'].values()), {})
                if 'date' in first_day:
                    summary['start_date'] = first_day['date']
            
            # Get end_date from itinerary if available
            if 'itinerary' in normalized and normalized['itinerary']:
                last_day = list(normalized['itinerary'].values())[-1] if normalized['itinerary'] else {}
                if 'date' in last_day:
                    summary['end_date'] = last_day['date']
            
            # Get weather info from practical_info if available
            if 'practical_info' in normalized and normalized['practical_info'].get('weather'):
                summary['weather_info'] = normalized['practical_info']['weather']
            
            # Create travel theme from destination
            if 'destination' in summary and not summary.get('travel_theme'):
                summary['travel_theme'] = ''
        
        logger.info(f"[DEFENSIVE] Normalized AI response keys: {list(normalized.keys())}")
        logger.info(f"[DEFENSIVE] Contents of 'itinerary' after normalization: {normalized.get('itinerary', 'N/A')}")
        logger.info(f"[DEFENSIVE] Contents of 'transportation' after normalization: {normalized.get('transportation', 'N/A')}")
        logger.info(f"[DEFENSIVE] Number of flights in transportation: {len(normalized.get('transportation', {}).get('fastest', [])) + len(normalized.get('transportation', {}).get('cheapest', [])) + len(normalized.get('transportation', {}).get('optimal', []))}")
        logger.info(f"[DEFENSIVE] Contents of 'accommodation' after normalization: {normalized.get('accommodation', 'N/A')}")
        logger.info(f"[DEFENSIVE] Contents of 'trip_summary' after normalization: {normalized.get('trip_summary', 'N/A')}")
        logger.info(f"[DEFENSIVE] Contents of 'practical_info' after normalization: {normalized.get('practical_info', 'N/A')}")

        logger.info(f"[DEFENSIVE] Contents of 'itinerary' after normalization: {normalized['itinerary']}")
        return normalized, False  # Return False to indicate this is a complete response
    
    def _enhance_with_real_booking_links(self, itinerary: Dict[str, Any], 
                                       hotel_data: Dict[str, Any], 
                                       flight_data: Dict[str, Any],
                                       request: TripPlanRequest,
                                       weather_data: Dict[str, Any] = None,
                                       original_ai_response: Dict[str, Any] = None) -> Dict[str, Any]:
        """Enhance the AI-generated itinerary with real booking links and data, preserving all AI fields."""
        import logging
        logger = logging.getLogger("api.enhanced_ai_provider")
        # Defensive: Ensure itinerary, trip_summary, and practical_info are preserved
        must_have_fields = ["itinerary", "trip_summary", "practical_info"]
        for field in must_have_fields:
            if field not in itinerary and original_ai_response and field in original_ai_response:
                itinerary[field] = original_ai_response[field]
                logger.warning(f"[DEFENSIVE] Field '{field}' was missing after merging, restored from AI response.")
        
        # Enhance with weather data if available
        if weather_data and weather_data.get("weather_forecast"):
            itinerary = self._enhance_with_weather_data(itinerary, weather_data)
        
        logger.info(f"[DEFENSIVE] Final itinerary keys: {list(itinerary.keys())}")
        return itinerary
    
    def _enhance_with_weather_data(self, itinerary: Dict[str, Any], weather_data: Dict[str, Any]) -> Dict[str, Any]:
        """Enhance itinerary with real weather data"""
        try:
            weather_forecast = weather_data.get("weather_forecast", {})
            forecasts = weather_forecast.get("forecasts", [])
            
            if not forecasts:
                return itinerary
            
            # Add weather summary to trip_summary
            if "trip_summary" in itinerary:
                # Calculate average temperature
                temps_c = [f.get("temp_max", 0) for f in forecasts if f.get("temp_max")]
                if temps_c:
                    avg_temp_c = sum(temps_c) / len(temps_c)
                    avg_temp_f = (avg_temp_c * 9/5) + 32
                    
                    # Get weather conditions
                    conditions = [f.get("weather", "").lower() for f in forecasts]
                    unique_conditions = list(set(conditions))
                    
                    itinerary["trip_summary"]["weather_summary"] = {
                        "avg_temp_f": round(avg_temp_f, 1),
                        "avg_temp_c": round(avg_temp_c, 1),
                        "conditions": ", ".join(unique_conditions),
                        "packing_tip": self._get_weather_packing_tip(avg_temp_c, conditions)
                    }
            
            # Add daily weather to itinerary
            if "itinerary" in itinerary:
                for i, forecast in enumerate(forecasts, 1):
                    day_key = f"day_{i}"
                    if day_key in itinerary["itinerary"]:
                        temp_c = forecast.get("temp_max", 0)
                        temp_f = (temp_c * 9/5) + 32
                        
                        itinerary["itinerary"][day_key]["weather"] = {
                            "temperature_f": round(temp_f, 1),
                            "temperature_c": round(temp_c, 1),
                            "condition": forecast.get("weather", "unknown"),
                            "description": forecast.get("description", ""),
                            "humidity": forecast.get("humidity", 0),
                            "wind_speed": forecast.get("wind_speed", 0)
                        }
            
            logger.info("Weather data successfully integrated into itinerary")
            return itinerary
            
        except Exception as e:
            logger.error(f"Error enhancing itinerary with weather data: {e}")
            return itinerary
    
    def _get_weather_packing_tip(self, avg_temp_c: float, conditions: List[str]) -> str:
        """Generate packing tip based on weather conditions"""
        if avg_temp_c < 10:
            return "Pack warm clothing, layers, and winter gear"
        elif avg_temp_c > 25:
            return "Pack light, breathable clothing and sun protection"
        elif any("rain" in c for c in conditions):
            return "Pack rain gear and waterproof shoes"
        elif any("snow" in c for c in conditions):
            return "Pack winter gear and check road conditions"
        else:
            return "Pack comfortable layers for variable weather"
    
    def _format_hotel_price(self, price: Any) -> str:
        """Format hotel price to be user-friendly and consistent"""
        try:
            if price is None:
                return "$0"
            
            # Convert to float if it's a string or other type
            if isinstance(price, str):
                price = float(price)
            elif isinstance(price, (int, float)):
                price = float(price)
            else:
                return "$0"
            
            # Round to 2 decimal places for currency display
            price = round(price, 2)
            
            # Format as currency
            return f"${price:.2f}"
            
        except (ValueError, TypeError):
            return "$0"
    
    def _generate_hotel_deep_link(self, hotel: Dict[str, Any], destination: str, checkin_date: str, checkout_date: str, travelers: int) -> str:
        """Generate a proper deep link for specific hotel booking using Google Hotels
        
        Note: Prices shown in our system may differ from Google Hotels due to:
        - Real-time pricing and availability
        - Special deals and discounts
        - Different currency conversions
        - Taxes and fees inclusion
        """
        try:
            # Google Hotels uses a complex parameter system that's difficult to replicate
            # Let's use a simpler, more reliable approach that will work consistently
            
            # Use the destination from the request instead of hotel location
            if not destination or destination.strip() == "":
                destination = "Unknown"
            
            # Format dates properly
            from datetime import datetime
            try:
                checkin_parsed = datetime.strptime(checkin_date, "%Y-%m-%d")
                checkout_parsed = datetime.strptime(checkout_date, "%Y-%m-%d")
                formatted_checkin = checkin_parsed.strftime("%Y-%m-%d")
                formatted_checkout = checkout_parsed.strftime("%Y-%m-%d")
            except:
                formatted_checkin = checkin_date
                formatted_checkout = checkout_date
            
            # Create a more specific Google Hotels search URL that includes the hotel name
            # This will help users find the specific hotel more easily
            from urllib.parse import quote
            destination_encoded = quote(destination)
            
            # Get hotel name for more specific search
            hotel_name = hotel.get("name", "").strip()
            if hotel_name and hotel_name.lower() != "hotel" and hotel_name.lower() != "unknown":
                # Include hotel name in search for more specific results
                hotel_name_encoded = quote(hotel_name)
                return f"https://www.google.com/travel/hotels/search?q={hotel_name_encoded}%20in%20{destination_encoded}%20from%20{formatted_checkin}%20to%20{formatted_checkout}"
            else:
                # Fallback to general destination search if no specific hotel name
                return f"https://www.google.com/travel/hotels/search?q=Hotels%20in%20{destination_encoded}%20from%20{formatted_checkin}%20to%20{formatted_checkout}"
            
        except Exception as e:
            logger.error(f"Error generating hotel deep link: {str(e)}")
            # Fallback to basic Google Hotels search
            hotel_name = hotel.get("name", "").strip()
            if hotel_name and hotel_name.lower() != "hotel" and hotel_name.lower() != "unknown":
                return f"https://www.google.com/travel/hotels/search?q={hotel_name}%20in%20{destination}%20from%20{checkin_date}%20to%20{checkout_date}"
            else:
                return f"https://www.google.com/travel/hotels/search?q=Hotels%20in%20{destination}%20from%20{checkin_date}%20to%20{checkout_date}"
    
    def _generate_flight_deep_link(self, origin: str, destination: str, date: str, travelers: int, flight: Dict[str, Any]) -> str:
        """Generate a proper deep link for specific flight booking using Google Flights"""
        try:
            # Google Flights has changed their URL structure multiple times
            # Let's use the most reliable approach - direct search with basic parameters
            
            # Format the date properly (YYYY-MM-DD)
            from datetime import datetime
            try:
                parsed_date = datetime.strptime(date, "%Y-%m-%d")
                formatted_date = parsed_date.strftime("%Y-%m-%d")
            except:
                formatted_date = date
            
            # Create a simple, reliable Google Flights search URL
            # This will take users to Google Flights with the route pre-filled
            from urllib.parse import quote
            origin_encoded = quote(origin)
            destination_encoded = quote(destination)
            
            # Use the most reliable Google Flights URL structure
            # This format should work consistently
            return f"https://www.google.com/travel/flights/search?q=Flights%20from%20{origin_encoded}%20to%20{destination_encoded}%20on%20{formatted_date}"
                
        except Exception as e:
            logger.error(f"Error generating flight deep link: {str(e)}")
            # Fallback to the most basic Google Flights search
            from urllib.parse import quote
            return f"https://www.google.com/travel/flights/search?q=Flights%20from%20{quote(origin)}%20to%20{quote(destination)}%20on%20{date}"
    
    def _get_kid_friendly_context(self, request: TripPlanRequest) -> str:
        """Generate kid-friendly context for the AI prompt"""
        # Safely access smart_trip_data with fallback
        smart_trip_data = getattr(request, 'smart_trip_data', {}) if hasattr(request, 'smart_trip_data') else {}
        kids_info = getattr(request, 'kids_info', None) or smart_trip_data.get('kids_info', {}) if smart_trip_data else {}
        
        if not kids_info:
            return "No specific kid information provided - plan for general travelers."
        
        count = kids_info.get('count', 0)
        ages = kids_info.get('ages', [])
        category = kids_info.get('category', 'children')
        age_range = kids_info.get('age_range', '')
        
        kid_context = f"""
**FAMILY TRAVEL PLANNING:**
- **Kids**: {count} {category}
- **Ages**: {age_range if age_range else 'Not specified'}
- **Category**: {category.title()}

**KID-FRIENDLY REQUIREMENTS:**
"""
        
        if category == 'toddlers':
            kid_context += """
- Include playgrounds, interactive museums, and safe outdoor spaces
- Plan shorter activity durations (1-2 hours max)
- Include nap time considerations in itinerary
- Recommend family-friendly restaurants with high chairs
- Suggest hotels with cribs/playpens available
- Include easy walking routes and stroller-friendly paths
"""
        elif category == 'children':
            kid_context += """
- Include educational attractions, zoos, aquariums, and interactive museums
- Plan mix of active and quiet activities
- Include kid-friendly restaurants and food options
- Suggest hotels with pools and family rooms
- Include parks and outdoor activities
- Plan for bathroom breaks and snack times
"""
        elif category == 'teens':
            kid_context += """
- Include adventure activities, shopping, and social spaces
- Plan for more independence and longer activity durations
- Include trendy restaurants and cafes
- Suggest hotels with good WiFi and social spaces
- Include photo-worthy locations and social media spots
- Plan for some adult activities with teen-friendly alternatives
"""
        
        kid_context += f"""
**SPECIFIC CONSIDERATIONS FOR {request.destination}:**
- Research kid-friendly attractions in the destination
- Include family-friendly transportation options
- Plan for weather-appropriate activities
- Consider meal times and kid-friendly dining options
- Include backup indoor activities for bad weather
- Plan for appropriate rest periods between activities
"""
        
        return kid_context